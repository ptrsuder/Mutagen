{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Mutagen is a C# library for analyzing, modifying, and creating Bethesda mods. One of its main features is offering interfaces and classes for the records that exist at compile time and are first class citizens in C#. With actual members for each field they get the benefits of type safety, simple live debugging, Intellisense features such as autocomplete. The interfaces offer clean API to the user and abstract away much of the binary record specifics and oddities of how they are stored on disk, while the actual implementation remains very closely tied to the data offering as much speed as it can by leveraging some of the latest C# features. Most of the public facing API is created by code generation, with small manual snippets of code for the one-off special cases. This means the library is able to provide consistent API with very little manual work when adding new record definitions or features.</p>"},{"location":"#goals","title":"Goals","text":"<p>What is Mutagen trying to provide? - Ability to analyze, create, or manipulate Bethesda mods in C#. - Strongly typed objects and fields for all records, which naturally offer Intellisense and type safety. - User abstraction from complex binary record structures/patterns, when appropriate and beneficial. - Frameworks for accomplishing common tasks - Performance via intelligent short circuiting of work and minimal internal layers underneath the API. - Heavy use of generated code to provide the above goals without requiring verbose manual development or maintenance. - Powerful but gritty low level tools for those that want to forgo the autogenerated classes for special tasks.</p>"},{"location":"#sample-api","title":"Sample API","text":"<p>A small snippet showing how to print some EditorIDs <pre><code>// A function that loops over any major records, and prints their unique EditorIDs\nvoid PrintAll(IEnumerable&lt;IMajorRecordCommonGetter&gt; records)\n{\nforeach (var editorId in records\n.Select(record =&gt; record.EditorID)\n.Where(edid =&gt; !edid.IsNullOrWhitespace())\n.Distinct())\n{\nSystem.Console.WriteLine(editorId);\n}\n}\n\n// Create a bootstrapping state object with entry points for a typical installation\nusing var env = GameEnvironment.Typical.Skyrim(SkyrimRelease.SkyrimSE);\n// Print all winning override weapon from all active mods in the game\nPrintAll(env.LoadOrder.PriorityOrder.Weapon().WinningOverrides());\n\n// Print all armors from a specific mod\nusing var mod = SkyrimMod.CreateFromBinaryOverlay(Path.Combine(env.DataFolderPath, \"MyMod.esp\"));\nPrintAll(mod.Armors);\n</code></pre></p>"},{"location":"#major-features","title":"Major Features","text":"<p>Check out the Wiki for more detailed explainations of Mutagen's API, and more typical use cases and examples.</p>"},{"location":"#plugins","title":"Plugins","text":"<p>Importing, exporting, and manipulating plugins (esp/esm.esl files)  - Mutable Classes  - Lightweight Read-only Access  - Enhanced FormID Concepts</p>"},{"location":"#linking-and-record-lookups","title":"Linking and Record Lookups","text":"<p>Following FormID pointers and looking up records by FormID/FormKey/EditorID  - Record Lookup  - Context Concepts  - Mutable vs Immutable Caches</p>"},{"location":"#load-order","title":"Load Order","text":"<p>Accessing the order mods should load and override one another  - Read/Write support  - Live monitoring that adapts to on-disk changes  - Winning Override Iteration</p>"},{"location":"#archives-bsaba2","title":"Archives (Bsa/Ba2)","text":"<p>Extracting assets from archive files  - Read support</p>"},{"location":"#strings","title":"Strings","text":"<p>Multi language string support systems  - Dictionary Style API  - Read/Write support</p>"},{"location":"#wpf-ui-controls","title":"WPF UI Controls","text":"<p>Controls that can be used in any WPF app  - FormKey Pickers  - ModKey Pickers  - Load Order display and manipulation</p>"},{"location":"#seeing-mutagen-in-action","title":"Seeing Mutagen in Action","text":""},{"location":"#synthesis","title":"Synthesis","text":"<p>Synthesis is a patcher pipeline built on top of Mutagen, and it already has a large library of example patchers to study and get inspiration from.</p>"},{"location":"#example-project","title":"Example Project","text":"<p>Another option is the Mutagen Bootcamp project.  It contains a good number of example tasks which you can run after pointing it to your copy of Skyrim.  It should be a good starter to help you understand the basics and actually see some of the processing in action.</p>"},{"location":"#installing-mutagen","title":"Installing Mutagen","text":"<p>Mutagen can be added to your C# project via NuGet, under the package name <code>Mutagen.Bethesda</code>.  Search for it in Visual Studio, or find it here.</p> <p>If you're unfamiliar with setting up C# projects in general, a good place to start might be creating a simple Synthesis patcher, and be sure to ask questions on our Discord.</p>"},{"location":"Installing-Visual-Studio/","title":"Installing Visual Studio","text":"<p>Visual Studio is the typical IDE (Integrated Development Environment) used for C#.  It is used for writing code, error checking, building, running, debugging, etc.  There are alternatives such as Rider, or VSCode, but VS will be used in this 101 tutorial.</p>"},{"location":"Installing-Visual-Studio/#downloading-visual-studio","title":"Downloading Visual Studio","text":"<p>Here is the latest link for downloading Visual Studio.  Feel free to go to Microsoft's site or Google for it as well.</p> <p>You are after the \"Visual Studio Community Edition\", which is the free version available to everyone.</p>"},{"location":"Installing-Visual-Studio/#installation-options","title":"Installation Options","text":"<p>Visual Studio can be used for a variety of things, such as Web, Game, or Mobile, or even C++ coding.  The Visual Studio Installer lets you customize and choose what modules you want to install. </p>"},{"location":"Installing-Visual-Studio/#c-desktop-development-modules","title":"C# Desktop Development Modules","text":""},{"location":"Installing-Visual-Studio/#ensure-net-standard-21-is-installed","title":"Ensure .NET Standard 2.1 is Installed","text":""},{"location":"Installing-Visual-Studio/#let-it-install-start-it-up","title":"Let It Install, Start It Up","text":"<p>Click install.  Let it download and install everything.  It may want to restart your computer.  </p> <p>At this point, your Start Menu should have <code>Visual Studio Community</code> added and you can start it up.</p>"},{"location":"Installing-Visual-Studio/#initial-setup","title":"Initial Setup","text":""},{"location":"Installing-Visual-Studio/#skip-creatingopening-a-project-for-now","title":"Skip Creating/Opening a Project For Now","text":"<p>You can create a new project now, but that will be covered in the next section.  For now just skip things so we can get to Visual Studio for initial settings adjustments.</p>"},{"location":"Installing-Visual-Studio/#dark-mode","title":"Dark Mode","text":"<p>Obviously, you'll want to switch it into Dark Mode. <code>Tools -&gt; Options -&gt; Environment -&gt; General -&gt; Color Theme -&gt; Dark</code></p>"},{"location":"Installing-Visual-Studio/#keybinds","title":"Keybinds","text":"<p>There are a few keybind schemes you can choose from.  This bootstrap guide will use <code>Visual C# 2005</code> keybinds. <code>Tools -&gt; Options -&gt; Enviornment -&gt; Keyboard -&gt; \"Apply the following...\" Top dropdown</code></p> <p>ReSharper (JetBrains) is another popular alternative.  Feel free to choose your preferred setup.</p>"},{"location":"Installing-Visual-Studio/#good-to-go","title":"Good to Go","text":"<p>At this point, you should have Visual Studio installed and ready to create your first C# project.</p>"},{"location":"LinkCache---Record-Lookup/","title":"LinkCache   Record Lookup","text":"<p>Records commonly have \"pointers\" to other records via FormLink members, which are an enhancement wrapper around a FormID.  To look up the record being referenced requires two things: - A relative context to look up against.  Is the lookup relative to a single <code>Mod</code>, or a <code>LoadOrder</code>? - Work to be done to iterate over all records in a <code>Mod</code> or <code>LoadOrder</code>, so that it can be determined if the record is present.</p> <p>In Mutagen, these concepts are contained in an object called <code>LinkCache</code>.  These objects help give the user direct control over: - What to link against - How long to persist any cached information about lookups</p>"},{"location":"LinkCache---Record-Lookup/#creating-a-linkcache","title":"Creating a LinkCache","text":"<pre><code>// This LinkCache will look inside the Mod for any records\nILinkCache&lt;OblivionMod&gt; modLinkCache = mod.CreateLinkCache();\n\n// This LinkCache will look inside the LoadOrder for any records\nILinkCache&lt;OblivionMod&gt; loadOrderLinkCache = loadOrder.CreateLinkCache();\n</code></pre> <p>An important aspect of LinkCaches is the context they are attached to: - From a Mod: It will look up records as they exist in that mod.  If a queried record does not explicitly exist in that mod in some form, it will not be located. - From a Load Order It will look up records based on Load Order priority.  A queried record will return the version from the latest mod that contains it.  This is the version that will be loaded and seen in-game.</p>"},{"location":"LinkCache---Record-Lookup/#querying-a-linkcache","title":"Querying a LinkCache","text":"<p>Here's an example of looking up an NPC's Race. <pre><code>ILinkCache&lt;OblivionMod&gt; linkCache = ...;\nNPC npc = ...;\nif (npc.Race.TryResolve(linkCache, out var race))\n{\nSystem.Console.WriteLine($\"{npc.EditorID} was of race {race.EditorID}\");\n}\nelse\n{\nSystem.Console.WriteLine($\"{npc.EditorID} had no race, or it wasn't found\");\n}\n</code></pre></p>"},{"location":"LinkCache---Record-Lookup/#lookup-optimizations","title":"Lookup Optimizations","text":""},{"location":"LinkCache---Record-Lookup/#lazy-lookup-and-caching","title":"Lazy Lookup and Caching","text":"<p>A <code>LinkCache</code> does no work until a record lookup is requested, at which point it will attempt to do the least amount of work possible to locate the record in the context it was created from.  LinkCache remembers any work done so if a second similar record is queried it will return immediately.</p>"},{"location":"LinkCache---Record-Lookup/#short-circuiting-on-type","title":"Short Circuiting on Type","text":"<p>One aspect of this that might not be immediately apparent is that a LinkCache only queries the appropriate Group.  A linking algorithm that is just based on FormIDs has to iterate over every single record, as that FormID could theoretically point to any record.  However, since FormLinks are associated with a record type as well, the LinkCache is able to short circuit and only search in the appropriate group.  This avoids a lot of unnecessary work.</p>"},{"location":"LinkCache---Record-Lookup/#short-circuiting-on-depth","title":"Short Circuiting on Depth","text":"<p><code>LinkCache</code>s relative to <code>LoadOrder</code>s also have shortcircuiting on type, but additionally also short circuit to only search as \"deep\" as needed.  For example, if a <code>LoadOrder</code> has 27 mods and a lookup finds its match after only processing the top 3 mods, then any further work will be skipped.</p> <p>If later a record is queried contained in a mod deeper than 3 levels, it will then do the additional work to search deeper into the LoadOrder.</p>"},{"location":"LinkCache---Record-Lookup/#cache-lifetime-control","title":"Cache Lifetime Control","text":"<p><code>LinkCache</code> objects cache information about past lookups, so the information can be returned immediately for subsequent lookups.  One aspect of this is that an internal <code>Dictionary&lt;FormKey, IMajorRecord&gt;</code> exists, where a <code>LinkCache</code> retains references to the <code>MajorRecord</code>s it found.  This can ruin the low memory footprint of the Binary Overlay pattern.  As such, it might be important for a user to have control over when/how caches are retained.</p> <p>Because a <code>LinkCache</code> is just an object the user created, they can choose how long they want the cache to persist.  If a cache is becoming too big and is a strain on memory usage, a user can choose to make a new instance or <code>.Clear()</code> the cache.  A <code>LinkCache</code> can be made once for the lifetime of the program, or they can be created and released to GC frequently (at the expense of lost lookup work).  The user is in charge of choosing the patterns that suit their needs best.</p>"},{"location":"LinkCache---Record-Lookup/#modification-safety","title":"Modification Safety","text":"<p>One important thing to note about <code>LinkCache</code>s is that they are not \"modification safe\".  This means that if a <code>Mod</code> or <code>LoadOrder</code> is modified, then existing <code>LinkCache</code> objects looking at them are no longer reliable.  </p> <p>New <code>LinkCache</code>s should be constructed after any modifications that: - Add or Remove a <code>MajorRecord</code> in a mod - If <code>Mod</code>s are added/removed/reordered on a <code>LoadOrder</code></p> <p>Changing values inside of a <code>MajorRecord</code> (Name/Health/etc) is safe to do and will not cause <code>LinkCache</code> corruption.</p>"},{"location":"New-Project-With-Mutagen/","title":"Create a New Project","text":"<p>At this point, you should have Visual Studio installed and open.</p> <p>You will want to create a new Project to get started.  A Project is a collection of code that results in either an executable (exe), or a reusable library (dll).</p> <p>You will want to make an executable project for this 101 tutorial. - <code>File -&gt; New -&gt; Project</code> - Find and select <code>Console App (.NET Core)</code>.   Note there are alternative options such as .NET Framework; Do not select those. - Modify the location to be to your preference</p> <p>Side note:  A Solution will be made alongside your initial project.  A Solution is just a workspace where multiple projects can exist, which may or may not use and be related to each other.  This then lets you build all projects at once if you have multiple.</p>"},{"location":"New-Project-With-Mutagen/#add-mutagen-via-nuget","title":"Add Mutagen via NuGet","text":""},{"location":"New-Project-With-Mutagen/#starter-project-automatically-added","title":"Starter Project Automatically Added","text":""},{"location":"Setting-Up-Your-First-Project/","title":"Setting Up Your First Project","text":"<p>As with most things, getting initially familiar with a new setup is always a hard leap.  This section is a 101 bootstrap to get you started with a C# project utilizing Mutagen that you can run and use as a foundation.  Whether you use that project to just experiment, create a patcher, or create an entirely different application is up to you.</p>"},{"location":"best-practices/Accessing-Known-Records/","title":"Accessing Known Records","text":""},{"location":"best-practices/Accessing-Known-Records/#recommended-patterns","title":"Recommended Patterns","text":"<p>Often, especially for base master files like <code>Skyrim.esm</code>, there are specific records that you want to look up.</p> <p>The recommended strategy is to use the FormKeys library, which lets you refer to records by EditorID, while still using FormKeys under the hood: <pre><code>var env = ...; // Some environment, like Synthesis, or Mutagen's GameEnvironment\n\nif (Skyrim.Race.ArgonianRace.TryResolve(env.LinkCache, out var race))\n{\n    Console.WriteLine($\"Found the race record\");\n}\n</code></pre></p> <p>The following sections will outline the alternatives and reasoning for the recommended best practices.</p>"},{"location":"best-practices/Accessing-Known-Records/#desire-to-access-known-records","title":"Desire To Access Known Records","text":""},{"location":"best-practices/Accessing-Known-Records/#by-formkey","title":"By FormKey","text":"<p>For example, if you wanted to look up the Argonian Race record, you might do the following: <pre><code>var env = ...; // Some environment, like Synthesis, or Mutagen's GameEnvironment\n\nvar formKey = FormKey.Factory(\"123456:Skyrim.esm\");\n\nif (env.LinkCache.TryResolve&lt;IRaceGetter&gt;(formKey, out var race))\n{\nConsole.WriteLine($\"Found the race record\");\n}\n</code></pre></p> <p>First, a FormKey is created pointing to the known record for the Argonian race in Skyrim.esm.   Then the link cache is asked to resolve the winning override for the record.  This will retrieve the winning override.</p> <p>However, there's a few annoyances: - Neither the dev nor future readers know the FormID for records offhand, and so must always look them up. - The only indication that <code>123456</code> points to the argonian race is to look it up and check, or hope the variable is named something intelligent (like <code>argonianRaceFormKey</code>) - Potential for typos.  What if it was actually <code>123457</code> and got mis-copied?</p>"},{"location":"best-practices/Accessing-Known-Records/#editorid","title":"EditorID","text":"<p>EditorIDs are a common alternative for looking up records, as they are human readable.</p> <pre><code>var env = ...; // Some environment, like Synthesis, or Mutagen's GameEnvironment\n\nif (env.LinkCache.TryResolve&lt;IRaceGetter&gt;(\"ArgonianRace\", out var race))\n{\nConsole.WriteLine($\"Found the race record\");\n}\n</code></pre> <p>However, they are not recommended for general use, for the reasons outlined here.</p>"},{"location":"best-practices/Accessing-Known-Records/#neither-is-ideal","title":"Neither is Ideal","text":"<p>Neither direct FormKeys or EditorIDs are ideal for looking up known records.  This is why the recommended pattern is to use the FormLinks library to bridge the gap and get the best of both worlds</p>"},{"location":"best-practices/Enumerable-Laziness/","title":"Enumerable Laziness","text":""},{"location":"best-practices/Enumerable-Laziness/#setup","title":"Setup","text":"<p>One common pitfall related to Enumerable/LINQ usage.  Take this basic Synthesis patcher example: <pre><code>var weaponsWithDamageMoreThanTen = // Loop over all winning override weapons in the load order\nstate.LoadOrder.PriorityOrder.Weapon().WinningOverrides()\n// Only want ones with damage above 10\n.Where(x =&gt;\n{\nif (x.BasicStats == null) return false;\nreturn x.BasicStats.Damage &gt; 10;\n});\n\n// Print!\nConsole.WriteLine(\"Weapons with damage more than 10:\");\nforeach (var weaponGetter in weaponsWithDamageMoreThanTen)\n{\nConsole.WriteLine(weaponGetter.ToString());\n}\n</code></pre> This works as expected, printing lots of weapons to the console.</p>"},{"location":"best-practices/Enumerable-Laziness/#problem","title":"Problem","text":""},{"location":"best-practices/Enumerable-Laziness/#whats-the-problem","title":"What's the problem?","text":"<p>The variable <code>weaponsWithDamageMoreThanTen</code> is a deferred Linq statement.  Sometimes can also be called a \"naked\" or \"lazy\" Linq statement.</p>"},{"location":"best-practices/Enumerable-Laziness/#what-does-this-mean","title":"What does this mean?","text":"<p>This means <code>weaponsWithDamageMoreThanTen</code> does not contain all the weapons with damage more than 10.  Rather, it is instructions for HOW to iterate the load order to get weapons with damage more than 10.</p> <p>It is a set of instructions, not the actual data itself.</p>"},{"location":"best-practices/Enumerable-Laziness/#why-does-this-matter","title":"Why does this matter?","text":"<p>It matters because multiple usages of these instructions means multiple executions of the instructions to get the results.</p> <p>Consider this: <pre><code>// Print!  One usage\nConsole.WriteLine(\"Weapons with damage more than 10:\");\nforeach (var weaponGetter in weaponsWithDamageMoreThanTen)\n{\nConsole.WriteLine(weaponGetter.ToString());\n}\n\n// Do some work and add to the outgoing patch.  Two usage\nforeach (var weaponGetter in weaponsWithDamageMoreThanTen)\n{\n// Put in outgoing patch\nvar weapon = state.PatchMod.Weapons.GetOrAddAsOverride(weaponGetter);\n// Cut the damage in half\nweapon.BasicStats!.Damage /= 2;\n}\n</code></pre></p> <p>This will work and produce results.  However, it will take 2x the time as it could.</p> <p>The print logic will execute the instructions provided by <code>weaponsWithDamageMoreThanTen</code>.  It will go to disk, read the Weapon GRUP data, parse the GRUP data into hundreds of Weapon records, iterate all those objects through your 10 damage filter, and then print to the console.</p> <p>The 2nd loop will then run.  It will go to disk, read the Weapon GRUP data, parse the GRUP data into hundreds of Weapon records, iterate all those objects through your 10 damage filter, and then add half the damage and put it into the outgoing patch.</p> <p>Notice this logic read from the disk and parsed the weapons TWICE.  This is because <code>weaponsWithDamageMoreThanTen</code> contains instructions for HOW to retrieve the weapons.  So each usage of those instructions DOES that work again.</p> <p>This concept where each usage does the work again can get catastrophically slow depending on what you're doing.</p>"},{"location":"best-practices/Enumerable-Laziness/#solution","title":"Solution","text":"<p>Linq is powerful and useful, but with power comes responsibility. </p>"},{"location":"best-practices/Enumerable-Laziness/#small-metaphor","title":"Small Metaphor","text":"<p>A naked Linq statement is like a set of instructions.</p> <p>Which would be more efficient?</p> <p><code>Using instructions for how to make an airplane, and using them to construct a new airplane for every flight.</code></p> <p>Or </p> <p><code>Using instructions for how to make an airplane once ahead of time, and reusing that airplane for many flights.</code></p> <p>Obviously making one airplane and reusing it is the better option.</p> <p>Having instructions for how to make an airplane isn't a bad thing to have, but choosing when to execute those instructions is important.</p>"},{"location":"best-practices/Enumerable-Laziness/#the-fix","title":"The Fix","text":"<p>The fix is just to execute those instructions ahead of time once, so that downstream usages don't rerun the logic each time.  This can be done very simply: <pre><code>var weaponsWithDamageMoreThanTen = // Loop over all winning override weapons in the load order\nstate.LoadOrder.PriorityOrder.Weapon().WinningOverrides()\n// Only want ones with damage above 10\n.Where(x =&gt;\n{\nif (x.BasicStats == null) return false;\nreturn x.BasicStats.Damage &gt; 10;\n})\n// Tell the above instructions to run immediately\n// and put themselves into an array\n.ToArray();\n</code></pre></p> <p>That's it.  Now all the usages downstream will loop over the contents of the array, rather than rerunning the instructions for themselves.</p> <p>This is the equivalent of using the airplane instructions once to make a plane, and now it can be reused by everyone downstream.</p>"},{"location":"best-practices/Enumerable-Laziness/#why-is-linq-deferredlazy","title":"Why is Linq Deferred/Lazy?","text":"<p>It is important to understand why Linq statements are lazy in the first place?  Why have this dangerous behavior at all?</p> <p>The laziness of a Linq enumerable is actually very powerful, as it allows us to short circuit work that is not needed.</p> <p>Consider this: <pre><code>var npcs = state.LoadOrder.PriorityOrder.Npc().WinningOverrides();\n\nforeach (var npc in npcs)\n{\nif (npc.Name.Contains(\"Goblin\"))\n{\nConsole.WriteLine(\"Our game has a Goblin\");\nbreak;\n}\n}\n</code></pre></p> <p>This logic will parse Npc records on disk until it finds a Goblin.  It will then print and stop working.</p> <p>The laziness of the Linq statement means that we only execute the instructions UNTIL we find a goblin.  If the first Npc record we saw was a Goblin, the program will have only parsed one Npc record.  This would be VERY fast, then.</p> <p>Compare to this: <pre><code>var npcs = state.LoadOrder.PriorityOrder.Npc().WinningOverrides()\n.ToArray();\n\nforeach (var npc in npcs)\n{\nif (npc.Name.Contains(\"Goblin\"))\n{\nConsole.WriteLine(\"Our game has a Goblin\");\nbreak;\n}\n}\n</code></pre> We've added that ToArray() to turn the instructions into their results up front, storing them in an array.  In this case, this is NOT what we want.</p> <p>Now, if the Goblin was the first Npc record we found, we will still parse ALL Npcs in the game: 1)  Set up instructions for how to find npcs 2)  Do instructions once, putting all npcs into an array 3)  Loop over array, stopping once we find a goblin.</p> <p>Notice that the work was done ahead of time, so we couldn't short circuit the work early if we found what we wanted.  We will do ALL the work every time, even if we're tossing 99% of the results into the trash.</p>"},{"location":"best-practices/Enumerable-Laziness/#conclusion","title":"Conclusion","text":"<p>The laziness of Linq statements is a powerful tool, but it is very dangerous if misused, and so must be understood.</p> <p>If a Linq statement is going to be reused, consider calling a <code>ToArray</code> to do the work once ahead of time.</p> <p>If the Linq statement only has one user, it's better to leave as a Deferred Linq statement, so that that one user can choose to stop processing early.</p> <p>If you're unsure, it is usually better to use the <code>ToArray</code>.  Doing unnecessary work once is a better gamble than potentially doing the same work 1000x.</p>"},{"location":"best-practices/FormLink-vs-FormLinkNullable/","title":"FormLink vs FormLinkNullable","text":"<p>FormLinks are used widely as a strongly typed identifier of a record, as an alternative to FormID, EditorID, or even FormKey.</p> <p>When using them, though, there are two variants: - <code>FormLink</code> - <code>FormLinkNullable</code></p>"},{"location":"best-practices/FormLink-vs-FormLinkNullable/#which-you-should-use","title":"Which You Should Use","text":"<p>Generally, the answer is you should always use <code>FormLink</code>, rather than <code>FormLinkNullable</code>.</p> <p>Mutagen exposes <code>FormLinkNullable</code> in certain areas, but you yourself should rarely if ever decide to create a <code>FormLinkNullable</code> when writing your own code.</p>"},{"location":"best-practices/FormLink-vs-FormLinkNullable/#what-is-formlinknullable","title":"What is FormLinkNullable","text":"<p>If you shouldn't use it, what is <code>FormLinkNullable</code> for?</p> <p>It is used by Mutagen itself to expose a very specific difference in how FormIDs can be null within a binary file on the disk.</p> <p>A FormLinkNullable can be null in two ways:</p> <p>An example of this is in Skyrim Npc's Worn Armor.   It is a <code>FormID</code> in the subrecord <code>WNAM</code>, which points to an Armor an Npc wears. Consider how this Worn Armor can be null: - <code>WNAM</code>'s value can be 0 - WNAM can be missing entirely</p> <p>And how a <code>FormLinkNullable</code>'s <code>FormKey</code> will be exposed in those differing scenarios: - When <code>WNAM</code>s value is 0, <code>FormKey</code> will not be null, and will contain a zero ID - When <code>WNAM</code> is missing entirely, <code>FormKey</code> member will be null</p> <p>This difference lets you detect the various ways a FormID can be null on disk.  This subtle difference is not normally important, which is why FormLink itself has an <code>IsNull</code> member, which checks for both cases, and is preferable way to check for whether a FormID is null.</p> <p>For your own code, you should -not- use <code>FormLinkNullable</code>, as the above differences are not applicable for most program logic that is not interacting with an on-disk representation directly.</p>"},{"location":"best-practices/FormLinks-Always-Target-Getter-Interfaces/","title":"FormLinks Always Target Getter Interfaces","text":""},{"location":"best-practices/FormLinks-Always-Target-Getter-Interfaces/#complication","title":"Complication","text":"<p><code>FormLinks</code> are <code>FormKeys</code> with typing information mixed in as to which record type they should associate with.  As such, they require you specify the typing you want to target.  Assuming you just wanted to target Npcs, there are still a few options: - <code>Npc</code> -&gt; The direct class - <code>INpc</code> -&gt; The setter interface - <code>INpcGetter</code> -&gt; The readonly interface</p>"},{"location":"best-practices/FormLinks-Always-Target-Getter-Interfaces/#best-practice","title":"Best Practice","text":"<p>The correct usage (99% of the time) is to always use the <code>INpcGetter</code> readonly interface.</p> <p><code>IFormLinkGetter&lt;INpcGetter&gt;</code></p> <p>Or more rarely</p> <p><code>FormKey&lt;INpcGetter&gt;</code></p> <p>The above still has the generic targeting the getter interface <code>INpcGetter</code>, which is the important part</p>"},{"location":"best-practices/FormLinks-Always-Target-Getter-Interfaces/#why","title":"Why","text":"<p>Consider a LinkCache resolve.  A FormLink and a LinkCache are combined to look up a record with a specific FormKey and Type.  </p> <p>Using a non-getter interface is less ideal, because it limits the scope that the LinkCache can match against.  This might result in a failure to match where it might find the Npc with the target FormKey, but not be able to satisfy the more restrictive type. <pre><code>IFormLinkGetter&lt;INpc&gt; myTargetNpc = ...;\nif (myTargetNpc.TryResolve(myLinkCache, out var npc))\n{\n// Found a INpc!\n}\n</code></pre> The <code>TryResolve</code> call wants to return an <code>INpc</code> type to you.  But if all it can find is a readonly <code>INpcGetter</code>, it cannot pretend that it's settable, and so fails to match.  This is the result of you asking the system to find an Npc that is settable, when the ones that exist are only getters.</p> <p>You can solve this issue by modifying the TryResolve scope: <pre><code>IFormLinkGetter&lt;INpc&gt; myTargetNpc = ...;\nif (myTargetNpc.TryResolve&lt;INpcGetter&gt;(myLinkCache, out var npc))\n{\n// Found a INpcGetter!\n}\n</code></pre> But it's preferable to have just had the FormLink type target getters in the first place.</p> <p>There are very limited and intentional scenarios where having a FormLink target a mutable type is desirable, but for the most part it's a pitfall trap for new users.</p>"},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/","title":"FormLinks vs EditorID as Identifiers","text":""},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#editorid-vs-formlink","title":"EditorID vs FormLink","text":"<p>When choosing how you want to look up records, or store lists of record identifiers, there's the common choice between EditorIDs and FormLinks. </p> <p>For example, let's say you want to look up Skyrim's <code>ArmorImperialCuriass</code> <code>0136D5:Skyrim.esm</code>.</p> <p>You can either do it via EditorID: <pre><code>// EditorIDs are strings\nstring editorId = \"ArmorImperialCuriass\";\n// Look up via EditorID in the cache\nvar foundArmorRecord = myLinkCache.Resolve&lt;IArmorGetter&gt;(editorId);\n</code></pre> or by FormLink: <pre><code>// FormLinks contain type and a FormID\nIFormLinkGetter&lt;IArmorGetter&gt; link = FormKey.Factory(\"0136D5:Skyrim.esm\");\n// Can alternatively use the FormKeys library to avoid typing the ID by hand\nlink = Skyrim.Armor.ArmorImperialCuirass;\n// Look up the FormLink against the cache\nvar foundArmorRecord = link.Resolve(myLinkCache);\n</code></pre></p> <p>Similarly, you can store containers of identifiers via EditorID: <pre><code>var armors = new HashSet&lt;string&gt;();\narmors.Add(\"ArmorImperialCuriass\");\n</code></pre> or by FormLink: <pre><code>var armors = new HashSet&lt;IFormLinkGetter&lt;IArmorGetter&gt;&gt;();\narmors.Add(Skyrim.Armor.ArmorImperialCuirass);\n</code></pre></p> <p>What are the reasons for choosing one over the other?  Generally FormLinks are the recommended route.  This article will go over the differences and reasons why.</p>"},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#editorid-upsides","title":"EditorID Upsides","text":""},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#readability-and-formlink-mapping","title":"Readability and FormLink Mapping","text":""},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#editorids-are-more-readable","title":"EditorIDs are More Readable","text":"<p>We're going to start out with the one upside that EditorIDs have: readability.</p> <p><code>ArmorImperialCuriass</code> is much more human readable and understandable compared to <code>0136D5:Skyrim.esm</code>.</p> <p>Generally, this is the reason people initially gravitate towards EditorIDs, as lots of other tooling uses EditorIDs as they are more human friendly.</p>"},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#formlink-mapping-brings-readability-to-formlink-based-systems","title":"FormLink Mapping Brings Readability to FormLink-Based Systems","text":"<p>Work has been done to mitigate this readability downside of FormLinks.  FormLink Mapping is a system where you can point to a mod and generate mappings so that you can reference and use FormLinks by their EditorID name.</p> <p>This allows for the best of both worlds, where the code is human readable by writing EditorIDs, while still using FormLinks under the hood for the code to use.  These systems mostly nullify the readability problem that FormKeys have.</p> <pre><code>// Left hand side is a FormLink, but right hand side is written and readable like an EditorID\nIFormLinkGetter&lt;IArmorGetter&gt; myFormLink = Skyrim.Armor.ArmorImperialCuriass;\n</code></pre>"},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#editorid-downsides","title":"EditorID Downsides","text":"<p>As far as code is concerned, it is much more preferable to deal with FormLinks.  Here are some reasons EditorIDs can cause some problems.</p>"},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#overriding-mods-can-ruin-lookups","title":"Overriding Mods Can Ruin Lookups","text":"<p>Let's say you're looking for the Armor in question <code>ArmorImperialCuirass</code>.  You can look it up by EditorID: <pre><code>// Looking up to find a winning Armor override with EditorID \nvar foundArmorRecord = linkCache.Resolve&lt;IArmorGetter&gt;(\"ArmorImperialCuirass\");\n</code></pre> or check if it's in a set: <pre><code>myEditorIdSet.Add(\"ArmorImperialCuirass\");\n// Checking to see if a given record is within the set, by EditorID\nmyEditorIdSet.Contains(potentialMatchingArmorRecord.EditorID);\n</code></pre></p> <p>Both of these operations are fragile.  You're looking up a record by its EditorID, which is a field that mods are able to override and change.  It's not often recommended for mods to do so, but they do it.  So if ModA.esp decided to change <code>ArmorImperialCuriass</code> to <code>ImperialCuriass</code>, for whatever reason, then your check will fail to find the record.</p> <p>EditorID is mutable and inconsistent.  In contrast, a FormLink/FormKey/FormID is a constant immutable aspect of a record, and so lookups via FormLink will never fail, no matter what mods change what values: <pre><code>// Looking up to find a winning Armor override with the given FormID\nvar foundArmorRecord = myArmorLink.Resolve(linkCache);\n\nmyFormLinkSet.Add(Skyrim.Armor.ArmorImperialCuirass);\n// Checking to see if a given record is within the set, by FormID\nmyFormLinkSet.Contains(potentialMatchingArmorRecord);\n</code></pre> These will consistently connect with the record you're looking for no matter what mods have done to them.</p>"},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#type-info-is-lost-potentially-losing-speed","title":"Type Info Is Lost, Potentially Losing Speed","text":"<p>Mutagen gets a lot of its speed by short circuiting work that is unnecessary.  One of the ways it does this is by making use of the Type of record involved.  For example, if you tell the LinkCache it is an Armor you're looking for, then it can skip parsing 99% of <code>Skyrim.esm</code>.</p> <p>EditorIDs are just strings, and so have no type information.  So when looking up a record via EditorID, you ideally want to specify the type involved: <pre><code>// Specifying IArmorGetter speeds up the lookup\nvar foundArmorRecord = linkCache.Resolve&lt;IArmorGetter&gt;(\"ArmorImperialCuirass\");\n\n// Forgetting to specify type leads to parsing the entire mod's contents:\nvar foundArmorRecord = linkCache.Resolve(\"ArmorImperialCuirass\");\n</code></pre></p> <p>FormLinks have type info built into their structure.  They are an ID + a Type.  As such, you do not need to remember to specify the type: <pre><code>// No need to specify type, as the FormLink we're Resolving knows its type: Armor\nvar foundArmorRecord = Skyrim.Armor.ArmorImperialCuirass.Resolve(linkCache);\n</code></pre></p>"},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#requires-decompression-losing-speed","title":"Requires Decompression, Losing Speed","text":"<p>This is due to a gritty implementation detail of how records are stored on disk.  A record's header is never compressed, while all the contents can be.  An EditorID is content that gets compressed.</p> <p>FormIDs are always in the same known location in the record header and never compressed.   So, when looking up records, a FormLink can simply look at a record to see if its a match at near instant speed.</p> <p>EditorID lookups, on the other hand, require the entire record's contents to be decompressed before it can begin looking for the EDID record to parse the string needed to see if the record is a match.</p> <p>So, by using EditorIDs as your lookup identifier, you're implicitly losing a good deal of speed by requiring the systems to do a bunch of potentially unnecessary work parsing a record you're not even interested in.</p>"},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#some-records-cannot-be-looked-up","title":"Some Records Cannot Be Looked Up","text":"<p>EditorIDs are not actually required.  Most of the common records people are interested in have them, but there are plenty of records that do not. </p> <p>This is more applicable for set building.  If you're compiling a <code>HashSet&lt;string&gt;</code> of EditorIDs of all records that satisfy XYZ, then some records might not be able to be put into the set. </p> <p>FormIDs are fundamental required data for a record to exist, and so are ensured to always be viable.</p>"},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#specialized-ui-input-systems","title":"Specialized UI Input Systems","text":"<p>The Mutagen ecosystem comes with specialized UI record pickers:</p> <p></p> <p>These allow users to search for records easily, and when a record is chosen, the FormLink in question is passed to the code.</p> <p>The system is not currently set up to bind to EditorIDs in the code backend.  As such, you'd likely have to instead use a list of raw strings.</p> <p>Theoretically the work could be done to expose it in a similar UI, but it has not been done because EditorIDs are generally less preferable to use for all the other reasons mentioned.</p>"},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#typos","title":"Typos","text":""},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#you-can-make-typos","title":"You Can Make Typos","text":"<p>EditorIDs are just raw strings, and so are vulnerable to typos: <pre><code>// Will never resolve, as we've misspelled Imperial\n// Compiler cannot give you a heads up, as it's just a raw string\nvar foundArmorRecord = linkCache.Resolve&lt;IArmorGetter&gt;(\"ArmorImprialCuirass\");\n</code></pre></p> <p>FormLinks would be vulnerable as well when typing in their ID, except when you're using the FormLink map systems: </p> <p>As a bonus, the IDE intellisense can suggest EditorIDs for you and autocomplete:</p> <p></p>"},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#your-users-can-make-typos","title":"Your Users Can Make Typos","text":"<p>Users will also have to deal with typos.  With EditorID based input, you're typically going to be exposing these via a list of strings on a UI or in a json file.  As they type in their desired records, they will be very vulnerable to making typos.  It's highly likely they don't realize and might complain to you the developer that your program is broken.  </p>"},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#string-comparisons-are-slower-than-int-comparisons","title":"String Comparisons Are Slower than Int Comparisons","text":"<p>I put this last, as it's a factor, but is minor compared to the other issues.  Comparing a long string of an EditorID like \"ArmorImprialCuirass\" is slower than comparing FormLinks which use integers for comparison.   As such, there will be a slight speed penalty.  Nothing to worry about too much, but just another small negative to add to the pile.</p>"},{"location":"best-practices/Getters-Everywhere/","title":"Getters Everywhere","text":""},{"location":"best-practices/Getters-Everywhere/#overview","title":"Overview","text":"<p>Mutagen offers up records in several ways.  Consider dealing with an Npc, it would offer: - <code>Npc</code> class.   A class with all the fields an Npc has - <code>INpc</code> interface.   An interface with all the fields an Npc has.  The class implements this. - <code>INpcGetter</code> interface.  An interface with all the fields an Npc has, but only gettable.  Cannot be modified.</p> <p>In most example code and projects you look at, most of the code will be dealing with <code>INpcGetter</code>, and you should too.</p>"},{"location":"best-practices/Getters-Everywhere/#best-practices","title":"Best Practices","text":"<p>The best practice is to have your code interact with Getter interfaces as much as possible.  Only at the last moment when you're sure you want to override a record and export it would you convert it to a settable version.</p> <p>A typical example: <pre><code>// Not using `var`, just for clarity in this example\nforeach (INpcGetter npcGetter in env.LoadOrder.PriorityOrder.Npc().WinningOverrides())\n{\n// Do all your filters on the getter version\nif (npcGetter.Configuration.Level &lt; 5) continue;\n\n// Found an Npc we want to modify.\n// Add to the outgoing mod and get a settable version as late as possible\nINpc npc = myPatchMod.Npcs.GetOrAddAsOverride(npcGetter);\nnpc.Level = 5;  }\n</code></pre></p>"},{"location":"best-practices/Getters-Everywhere/#reasoning","title":"Reasoning","text":""},{"location":"best-practices/Getters-Everywhere/#readonly-increases-speed","title":"Readonly Increases Speed","text":"<p>A lot of Mutagen's speed comes from short circuiting unnecessary work.  A big way it does this is by exposing records via Binary Overlays.  These are record objects that are very lightweight and fast.   But one of their downsides is they are read only.</p> <p>As soon as you want to modify something, you have to first convert it to a settable version of the record.  This means creating a more \"normal\" settable <code>Npc</code> class, and reading ALL the data within that record to fill out each field one by one.  This is often a waste of time.</p> <p>Take a look at our original example, if the Npc in question has a Level higher than 5, then all that work and time of reading the other fields is wasted.  Once we find out the level is higher than 5, we no longer care about it anymore, and would prefer to have not parsed any of the other data.  This is just one small example where it is preferable to remain in the parse-on-demand readonly mode as long as possible.</p>"},{"location":"best-practices/Getters-Everywhere/#adds-clearer-intention-to-modifications","title":"Adds Clearer Intention to Modifications","text":""},{"location":"best-practices/Getters-Everywhere/#a-fully-mutable-ecosystem-has-easy-pitfalls","title":"A Fully Mutable Ecosystem Has Easy Pitfalls","text":"<p>Let's pretend for a moment that all records were mutable within the entire ecosystem.  This can easily lead to some very subtle bug prone situations.</p> <pre><code>// Retrieve an Npc from Skyrim.esm\n// Making use of the Mutagen.Bethesda.FormKeys.Skyrim helper library\n// Note that in this pretend example, the environment is providing setter interfaces\nINpc orthorn = env.LoadOrder[\"Skyrim.esm\"].Npcs[Skyrim.Npc.Orthorn];\n\n// Modify speed to be x2\northorn.Speed *= 2;\n\n// Add to our outgoing patch\noutgoingPatch.Npcs.Add(orthorn);\n</code></pre> <p>The above logic has some unexpected and probably undesirable side effects.  We not only overrode Orthorn to have more Speed in our outgoing patch, we also modified the original record as it existed within the <code>Skyrim.esm</code> mod object!   In fact, it's the same Npc class instance shared by both mods!  Changing the values in one changes the values in all, as both mods are pointing to the same object.  If future code is to iterate Skyrim's records, it would see that Orthorn is faster there, too, rather than the record having the original speed Skyrim.esm defined.  </p> <p>Skyrim.esm should not be so easily modified.  We wanted to modify Orthorn as it was defined in our outgoing patch.  Skyrim.esm should be more or less immutable unless we take explicit intentional steps to do so.</p>"},{"location":"best-practices/Getters-Everywhere/#initially-immutable-environment-encourages-clearer-intentions","title":"Initially Immutable Environment Encourages Clearer Intentions","text":"<p>Take the same situation, but in the actual ecosystem that provides getter interfaces by default: <pre><code>// Retrieve an Npc from Skyrim.esm\n// Making use of the Mutagen.Bethesda.FormKeys.Skyrim helper library\n// Note that the actual ecosystems provide only a Getter interface here\nINpcGetter orthornGetter = env.LoadOrder[\"Skyrim.esm\"].Npcs[Skyrim.Npc.Orthorn];\n\n// We want to modify, and so we have to indicate which mod wants to contain that modification\nvar orthornSetter = outgoingPatch.Npcs.GetOrAddAsOverride(orthornGetter);\n\n// Modify speed to be x2\northornSetter.Speed *= 2;\n</code></pre></p> <p>This is better in a few ways: - As part of the modification process, we are required to indicate which mod is going to \"house\" those modifications - The object instance we are modifying only exists in our outgoing patch, rather than many mods - The original Skyrim.esm definition is left intact.  In fact, it cannot possibly be modified as the entire mod object is readonly fundamentally.</p>"},{"location":"best-practices/ITPO-Avoidance/","title":"ITPO Avoidance","text":""},{"location":"best-practices/ITPO-Avoidance/#what-is-an-itpo","title":"What is an ITPO","text":"<p>A very typical thing that can happen during processing mods is exporting a record that doesn't have any changes compared to the original.  This is known as an ITPO (Identical to Previous Override), or sometimes ITM (Idential to Master).</p> <p>Mutagen may or may not get ITPO removal tooling in the future.  This would be powered by Equality/HashCode concepts, which already exist, but are not heavily tested for accuracy yet.  If/when ITPO removal calls do get implemented, it will mostly be for feature completeness, rather than necessity.</p> <p>How does one avoid/deal with ITPOs in the meantime, then?</p>"},{"location":"best-practices/ITPO-Avoidance/#avoiding-itpos","title":"Avoiding ITPOs","text":"<p>Typically, the best patterns avoid making ITPOs in the first place, rather than cleaning them up after they exist.</p> <p>For example, this code can make some ITPOs: <pre><code>foreach (var weapon in loadOrder.PriorityOrder.Weapon().WinningOverrides())\n{\nvar weaponOverride = outgoingMod.Weapons.GetOrAddAsOverride(weapon);\nweaponOverride.Weight = 0;\n}\n</code></pre> If a weapon already has a weight of zero, this will cause an ITPO.  We could add some code after to clean them up by looping over our outgoing mod, finding the previous override, checking equality, and then removing them from the outgoing patch if they're identical.</p> <p>Alternatively, we can adjust the logic to just never make an ITPO in the first place: <pre><code>foreach (var weapon in loadOrder.PriorityOrder.Weapon().WinningOverrides())\n{\n// If what we wanted to change is already as we want it, skip\nif (weaponOverride.Weight == 0) continue;\n\nvar weaponOverride = outgoingMod.Weapons.GetOrAddAsOverride(weapon);\nweaponOverride.Weight = 0;\n}\n</code></pre> As you can see, the call to <code>GetOrAddAsOverride</code> is delayed until we know there's a meaningful modification to do.</p> <p>Another common pattern for doing this looks like this: <pre><code>foreach (var weapon in loadOrder.PriorityOrder.Weapon().WinningOverrides())\n{\n// Make a mutable copy, but don't add it to the mod yet\nvar weaponOverride = weapon.DeepCopy();\n\nbool madeModification = false;\n\nif (weaponOverride.Weight != 0)\n{\nweaponOverride.Weight = 0;\nmadeModification = true;\n}\n\nif (weaponOverride.Value != 100)\n{\nweaponOverride.Weight = 100;\nmadeModification = true;\n}\n\n// If we didn't do anything, skip\nif (!madeModification) continue;\n\noutgoingMod.Weapons.Set(weaponOverride);\n}\n</code></pre></p> <p>There are many ways to achieve the same goal.  The important takeaway is that code should first try to not make any ITPOs in the first place by only adding it to the outgoing mod once/if modifications have been made to the record.  Depending on the complexity of what you're doing, it may require different patterns than the ones outlined above.  No matter what though, if you find yourself reaching for ITPO tooling, take a step back and see if you can refactor it to process a different way to avoid them altogether.</p>"},{"location":"best-practices/Modifying-Groups-Being-Iterated/","title":"Modifying Groups Being Iterated","text":""},{"location":"best-practices/Modifying-Groups-Being-Iterated/#looping-and-modifying-the-same-record-types","title":"Looping and Modifying the Same Record Types","text":"<p>Consider this: <pre><code>foreach (var lvln in state.LoadOrder.PriorityOrder.LeveledNpc().WinningOverrides())\n{\nvar lvlnCopy = lvln.DeepCopy();\nlvlnCopy.EditorId += \"Copy\";\n// Some modifications\nstate.PatchMod.LeveledNpcs.Set(lvlnCopy);\n}\n</code></pre> This code is dangerous, as it modifies the same record types it's inspecting.</p>"},{"location":"best-practices/Modifying-Groups-Being-Iterated/#modifying-a-collection-being-enumerated","title":"Modifying a Collection Being Enumerated","text":"<p>Consider this simpler code: <pre><code>var list = new List&lt;int&gt;();\nlist.Add(3);\nlist.Add(7);\nforeach (var item in list)\n{\n// Exception on next loop\nlist.Add(item * 2);\n}\n</code></pre> This code will throw an exception.  </p> <p>It is because this loop is modifying the <code>list</code> it is looping. The first loop iteration it will see <code>item = 3</code>, and add <code>6</code> to the list.</p> <p>It will then try to loop to the next item, but C# will throw an exception  <code>System.InvalidOperationException: Collection was modified; enumeration operation may not execute.</code></p> <p>In C#, you are not allowed to modify a collection as it's being looped.</p>"},{"location":"best-practices/Modifying-Groups-Being-Iterated/#avoiding-the-exceptions","title":"Avoiding the Exceptions","text":"<p>There are two routes to avoiding the <code>Collection was modified</code> exception</p>"},{"location":"best-practices/Modifying-Groups-Being-Iterated/#create-a-temporary-collection","title":"Create a Temporary Collection","text":"<p>This can be as simple as: <pre><code>foreach (var item in list\n// Now we're safe\n.ToArray())\n{\nlist.Add(item * 2);\n}\n</code></pre> The reason this works is that the <code>ToArray</code> call eagerly copies all the items from <code>list</code> to a new array.  The <code>foreach</code> loop then loops over that array.  Then, when you add an item to the list, you're not actually modifying the same collection you are looping, and so it succeeds.</p>"},{"location":"best-practices/Modifying-Groups-Being-Iterated/#stop-looping-after-modification","title":"Stop looping after modification","text":"<p>Sometimes for certain purposes, you want to stop the logic after modifying once. <pre><code>foreach (var item in list)\n{\nlist.Add(item * 2);\nbreak;\n}\n</code></pre> This self modification is allowed, because it is not the <code>list.Add</code> that is the problem, but rather the foreach loop trying to go to the next item right after.  So by breaking out of the loop, this code is safe.</p>"},{"location":"best-practices/Modifying-Groups-Being-Iterated/#applying-it-to-mutagen","title":"Applying it to Mutagen","text":"<p>Taking these same concepts back to Mutagen, if you're adding/removing/replacing records from a mod/group that you're looping, you can get the same exception.</p> <p>If you're modifying the same record types you are looping, then you can follow the same patterns described above.  Just add a <code>ToArray</code> to keep yourself from modifying the collections you are looping: <pre><code>foreach (var lvln in state.LoadOrder.PriorityOrder.LeveledNpc().WinningOverrides().ToArray())\n{\nvar lvlnCopy = lvln.DeepCopy();\nlvlnCopy.EditorId += \"Copy\";\n// Some modifications\nstate.PatchMod.LeveledNpcs.Set(lvlnCopy);\n}\n</code></pre></p> <p>Note that this only matters when you are Adding/Removing/Replacing a record FROM/TO a group in a mod.</p> <p>If you are just modifying fields on the records (Setting the name, for example), this is not dangerous.  In this situation, you are not actually modifying the collection itself, you're modifying a field on a record.</p>"},{"location":"best-practices/Reuse-Translation-Masks/","title":"Reuse Translation Masks","text":"<p>[[Translation Masks]] are a powerful toolset that give you fine-grained control over things like a Copy or Equality check.</p> <p>They typically look like this: <pre><code>var bookCopy = book.DeepCopy(new Book.TranslationMask(defaultOn: true)\n{\nPickUpSound = false,\nPutDownSound = false,\n});\n</code></pre> This code snippet would copy a book, but skip <code>PickUpSound</code> and <code>PutDownSound</code> and leave them on their default values.</p> <p>However, code like the ones above are typically done in loops: <pre><code>foreach (var book in books)\n{\nvar bookCopy = book.DeepCopy(new Book.TranslationMask(defaultOn: true)\n{\nPickUpSound = false,\nPutDownSound = false,\n});\n}\n</code></pre> This code will work, but is slightly wasteful, as it creates a new mask per loop iteration.</p> <p>A TranslationMask is just instructions for what to copy, so they can be reused.  A better way would look like this: <pre><code>var bookCopyMask = new Book.TranslationMask(defaultOn: true)\n{\nPickUpSound = false,\nPutDownSound = false,\n};\nforeach (var book in books)\n{\nvar bookCopy = book.DeepCopy(bookCopyMask);\n}\n</code></pre> Now the job is a bit more optimized, as the same mask can just be reused for each book.</p>"},{"location":"best-practices/TryGet-Concepts/","title":"TryGet Concepts","text":"<p>There are many concepts within Mutagen that are optional, nullable, or may not link up at runtime.</p> <p>It is good practice to code in a way that is able to handle both situations: - The field is not null.  The lookup found its target.  Etc - The field is null.  The lookup failed to find its target.  Etc</p> <p>To facilitate this, most API comes with <code>Try</code> alternatives.</p>"},{"location":"best-practices/TryGet-Concepts/#direct-access","title":"Direct Access","text":"<p>Let's first take a look at the non-Try route.</p> <p>This pattern assumes your lookup will succeed.  This is only safe if you checked that it existed earlier.</p>"},{"location":"best-practices/TryGet-Concepts/#mutagen-example","title":"Mutagen Example","text":"<p>An example: <pre><code>INpcGetter npc = ...;\n\nIRaceGetter race = npc.Race.Resolve(someLinkCache);\n</code></pre></p> <p>This will work in 98% of scenarios, up until some user has an odd Npc that doesn't list a Race.  Maybe it was a test Npc that isn't used anymore, so it's not a big deal, except for the fact that your code will now throw an exception.  It cannot <code>Resolve</code> the race and give you an object back, so it throws.</p>"},{"location":"best-practices/TryGet-Concepts/#generic-c-example","title":"Generic C# Example","text":"<p>This is equivalent to using the Dictionary indexer directly <pre><code>Dictionary&lt;int, string&gt; dict = new();\ndict[23] = \"Hello\";\n\n// I will throw\nvar str = dict[45];\n</code></pre></p>"},{"location":"best-practices/TryGet-Concepts/#tryget-patterns-instead","title":"TryGet Patterns Instead","text":"<p>Instead, a better pattern might be:</p>"},{"location":"best-practices/TryGet-Concepts/#mutagen-example_1","title":"Mutagen Example","text":"<pre><code>INpcGetter npc = ...;\n\nif (npc.Race.TryResolve(someLinkCache, out var race))\n{\nSystem.Console.WriteLine($\"Race was {race}\");\n}\nelse\n{\n// Did not find it.  Return? Skip?\n}\n</code></pre> <p>Often, if in a loop, the cleanest pattern is: <pre><code>foreach (INpcGetter npc in someCollection)\n{\n// Look it up, otherwise go to next npc\nif (!npc.Race.TryResolve(someLinkCache, out var race)) continue;\n\nSystem.Console.WriteLine($\"Race was {race}\");\n}\n</code></pre></p>"},{"location":"best-practices/TryGet-Concepts/#generic-c-example_1","title":"Generic C# Example","text":"<p>For the basic C# dictionary example, this would be the equivalent of: <pre><code>Dictionary&lt;int, string&gt; dict = new();\ndict[23] = \"Hello\";\n\nif (dict.TryGetValue(45, out var str))\n{\n// Found it\n}\n</code></pre></p>"},{"location":"best-practices/TryGet-Concepts/#summary","title":"Summary","text":"<p>It is almost always preferable to use the <code>Try</code> alternative when available.   It will force you to consider both when it finds what it was looking for, as well as the case when it does not.</p> <p>Straight \"<code>Try</code>-less\" calls should only be used when you've previously checked that the value exists.  Then you know the call is safe, and so it's proper to not need to <code>Try</code>.  This is rarely used, as the <code>Try</code> pattern both checks that it exists and gets the value in one swoop, so a followup retrieval is usually not needed.</p>"},{"location":"environment/","title":"Environment","text":"<p>When writing a program that is going to interact with Bethesda mods, there are several things you typically want to interact with.  Mutagen comes with a convenience bootstrapper object that constructs them all for a typical installation and exposes them all in one place:</p>"},{"location":"environment/#typical-single-game-usage","title":"Typical Single Game Usage","text":"<pre><code>using (var env = GameEnvironment.Typical.Skyrim(SkyrimRelease.SkyrimSE))\n{\n// Now we can get straight to work\nConsole.WriteLine($\"Data folder was found to be at: {env.DataFolderPath}\");\nConsole.WriteLine($\"Load Order has {env.LoadOrder.Count} mods\");\n\n// Let's print the load order as an example\nConsole.WriteLine($\"Load Order:\");\nforeach (var listing in env.LoadOrder.ListedOrder)\n{\nConsole.WriteLine($\"  {listing}\");\n}\n}\n// Environment is now disposed, so all contained objects are no longer accurate or valid\n</code></pre>"},{"location":"environment/#gameenvironmentstate","title":"GameEnvironmentState","text":"<p>The environment object that is given to you has lots of useful contextual items: - A LoadOrder object with the current load order  - ReadOnly Mod objects ready for use on the load order object, when they are found to exist - LinkCache relative to the load order - Data folder path - Load order file path (Plugins.txt) - Creation Club load order file path (Skyrim.ccc)</p>"},{"location":"environment/#advanced-usage","title":"Advanced Usage","text":"<p>The above example just shows the basic one line environment definition to get the typical environment.  Mutagen by default will construct Game Environments relative the game installation registered by Steam, as described here. </p> <p>If you have custom requirements or want to mix in output mods, etc, be sure to check out the Environment Construction documentation.</p>"},{"location":"environment/#synthesis-usage","title":"Synthesis Usage","text":"<p>If you're coding within a Synthesis Patcher, you should not make your own environment as described here.  Synthesis provides its own environment-like <code>IPatcherState</code> object in its Run function.  Read More</p>"},{"location":"environment/Environment-Construction/","title":"Environment Construction","text":""},{"location":"environment/Environment-Construction/#single-game-category-construction","title":"Single Game Category Construction","text":"<p>As mentioned in the overview section, the typical way to construct an environment if you know the game you want to target is: <pre><code>using (var env = GameEnvironment.Typical.Skyrim(SkyrimRelease.SkyrimSE))\n{\n// Use environment\n}\n</code></pre></p>"},{"location":"environment/Environment-Construction/#synthesis-usage","title":"Synthesis Usage","text":"<p>If you're coding within a Synthesis Patcher, you should not make your own environment as described here.  Synthesis provides its own environment-like <code>IPatcherState</code> object in its Run function.  Read More</p>"},{"location":"environment/Environment-Construction/#unknown-game-construction","title":"Unknown Game Construction","text":"<p>You can construct an environment when you don't know the target game: <pre><code>using (var env = GameEnvironment.Typical.Construct(someGameRelease))\n{\n// Use environment\n}\n</code></pre></p> <p>But this has the downside of not knowing the type of mod it will contain at compile time.  This means it will only expose <code>IModGetter</code> objects, which will be harder to interact with, depending on your goals</p>"},{"location":"environment/Environment-Construction/#game-environment-builder","title":"Game Environment Builder","text":"<p>Lets you fluently tweak the environment that will be built to be customized to your needs.</p>"},{"location":"environment/Environment-Construction/#problem","title":"Problem","text":"<p>There are a lot of times when the Single Game Category Construction game environment does not suit your needs.  Consider: - Wanting to omit a mod - Wanting to add an output mod, and integrate it with the link cache</p> <p>To do this with the simple bootstapper, you'd have to construct your own LoadOrder/LinkCache objects using the ones it gave you, but with your desired modifications.</p>"},{"location":"environment/Environment-Construction/#builder-pattern","title":"Builder Pattern","text":"<p>Instead, you can make use of the <code>GameEnvironmentBuilder</code> system: <pre><code>var outgoing = new SkyrimMod(ModKey.FromFileName(\"MyMod.esp\"), SkyrimRelease.SkyrimSE);\nusing var env = GameEnvironment.Typical.Builder&lt;ISkyrimMod, ISkyrimModGetter&gt;(GameRelease.SkyrimSE)\n.TransformLoadOrder(x =&gt; x.Where(x =&gt; !x.ModKey.Name.Contains(\"SkipMe\")))\n.WithTargetDataFolder(someCustomDataFolderPath)\n.WithOutputMod(outgoing)\n.Build();\n</code></pre> It uses a fluent API that lets you mix in the modifications you want to make to the environment as it's being built.  In this case the environment given to you will not include any mods that contain \"SkipMe\", will target a custom data folder specified, and will contain the <code>outgoing</code> mod at the end of its LinkCache.</p>"},{"location":"environment/Environment-Construction/#transform-load-order","title":"Transform Load Order","text":"<p>This gives you an Enumerable of mods, and lets you filter some out, or mix some in at your discretion.</p>"},{"location":"environment/Environment-Construction/#transformloadorderlistings","title":"TransformLoadOrderListings","text":"<p>This call gives you the listings as they appear in the load order files, before the mod objects get created.  Ideally any trimming is done here, rather than after the mods have been created.</p> <p>Order between multiple <code>TransformLoadOrderListings</code> is respected.</p>"},{"location":"environment/Environment-Construction/#transformmodlistings","title":"TransformModListings","text":"<p>This call gives you the listings after they have been transformed by any <code>TransformLoadOrderListings</code> calls, and after mod objects have been created for each listing.  As such, this call can interact with the mod objects as part of its transform logic.</p> <p>Order between multiple <code>TransformModListings</code> is respected, but will always come after any <code>TransformLoadOrderListings</code> calls.</p>"},{"location":"environment/Environment-Construction/#withoutputmod","title":"WithOutputMod","text":"<p>This lets you mix in a mod that you plan on exporting content with.  It will be added to the end of the LinkCache as a mutable mod that is safe to change.   You can put multiple <code>WithOutputMod</code> calls in your builder chain, and the order they appear will determine how they're placed on the Load Order and which ends up being the winning override.</p>"},{"location":"environment/Environment-Construction/#withtargetdatafolder","title":"WithTargetDataFolder","text":"<p>Allows you to customize what game folder the environment will be constructed against.  Useful when dealing with ad-hoc installations.</p>"},{"location":"environment/Environment-Construction/#withloadorder","title":"WithLoadOrder","text":"<p>This is a <code>TransformLoadOrderListings</code> style call that simply discards any existing load order and injects an explicitly provided one.  Will respect the ordering alongside other <code>TransformLoadOrderListings</code> phase calls.</p>"},{"location":"environment/Game-Locations/","title":"Game Locations","text":""},{"location":"environment/Game-Locations/#use-environments-when-possible","title":"Use Environments When Possible","text":"<p>Game location concepts are somewhat unnecessary to interact with, since usually the preferred entry point is via Environments</p> <p>This section will go over it anyway, as some more complex programs might want direct access to the logic.</p>"},{"location":"environment/Game-Locations/#game-locations_1","title":"Game Locations","text":""},{"location":"environment/Game-Locations/#game-folder-vs-data-folder","title":"Game Folder vs Data Folder","text":"<p>The <code>Game</code> folder is the one containing the game's exe itself.  This is not where mods go, typically.</p> <p>The <code>Data</code> folder is usually within the <code>Game</code> folder: <code>%Game%/Data</code>.  This is where mods reside, and as such is the typical folder of interest.</p>"},{"location":"environment/Game-Locations/#get__folder","title":"Get__Folder","text":"<p>You can query for a Game or Data folder easily: <pre><code>var dataFolder = GameLocations.GetDataFolder(GameRelease.SkyrimSE);\n</code></pre> Also via a Try pattern <pre><code>if (GameLocations.TryGetDataFolder(GameRelease.SkyrimSE, out var dataFolder))\n{\n}\n</code></pre></p>"},{"location":"environment/Game-Locations/#sources","title":"Sources","text":"<p>Currently, Mutagen locates games via a few sources: - Looks in the registry - Looks in Steam systems (via GameFinder)</p> <p>You can directly query the Registry, if you wish <pre><code>if (GameLocations.TryGetGameFolderFromRegistry(GameRelease.SkyrimSE, out var gameFolder))\n{\n}\n</code></pre></p>"},{"location":"environment/Game-Locations/#adhoc-installations","title":"AdHoc Installations","text":"<p>Note that this API will NOT locate ad-hoc game folders that exist randomly on your system.  It must be registered in one of the two above listed sources in order to be located.   Mutagen will not crawl the drives of your computer looking for installations.</p> <p>As such, installations like Wabbajack might have a game folder that is \"off the grid\".  In these situations, your tools need to offer some way for the user to define where their target data folder is, as the system will not be able to locate these unregistered folders automatically.</p>"},{"location":"environment/Game-Locations/#getgamefolders","title":"GetGameFolders","text":"<p>There is an enumerable option to get all the Game folders from the above listed sources.  Currently that will only return at max two. <pre><code>foreach (var location in GameLocations.GetGameFolders(GameRelease.SkyrimSE))\n{\n}\n</code></pre></p>"},{"location":"examples/Low-Level-Examples/","title":"Low Level Examples","text":""},{"location":"examples/Low-Level-Examples/#record-navigation-using-header-structs","title":"Record Navigation Using Header Structs","text":"<p>The following code will open a simple mod file from disk, and print all EditorIDs. </p> <pre><code>var meta = GameConstants.Oblivion;\nvar edid = new RecordType(\"EDID\");\nusing var stream = new BinaryReadStream(File.Open(path));\n\n// Read/Skip mod header\nstream.ReadModHeader(meta);\n\n// Read while stream has more data\nwhile (stream.Remaining &gt; 0)\n{\n// Read bytes then overlay a GroupHeader struct\nvar groupMeta = stream.ReadGroupHeader(meta);\n\n// Find the final position of the group's data\nvar finalPos = stream.Position + groupMeta.ContentLength;\n\n// Read while still in group's data\nwhile (stream.Position &lt; finalPos)\n{\n// Note we're switching to \"Frame\" mechanics, just for kicks\nvar majorFrame = stream.ReadMajorRecord(meta);\n\n// Iterate over subrecords\nforeach (var subRecord in majorFrame.EnumerateSubrecords())\n{\nif (subRecord.Header.RecordType == edid)\n{\nSystem.Console.WriteLine(subRecord.AsString(MutagenEncodingProvider.Instance.GetEncoding(GameRelease.Oblivion, Language.English)));\n}\n}\n}\n}\n</code></pre> <p>Note that the above code does not handle the complexity of Sub-Groups such as Cells/Worldspaces, and will break if the mod contains those types of records, unless upgraded to also handle them. </p> <p>However, it does give an extreme amount of control and flexibility of logic, while still abstracting the error prone concepts of header alignments away from the user.</p>"},{"location":"examples/Print-Some-Content/","title":"Print Some Content","text":"<p>This is the quintessential \"Hello World\" program in Mutagen flavor.</p> <p>Its goal is to load up a mod, and print the names of all the NPCs. <pre><code>using var mod = OblivionMod.CreateFromBinaryOverlay(pathToMod);\nforeach (var name in mod.NPCs.Records\n.Select(npc =&gt; npc.Name)\n.Distinct()\n.Where(s =&gt; !string.IsNullOrWhiteSpace(s)))\n{\nSystem.Console.WriteLine(name);\n}\n</code></pre></p> <p>An outline of what is going on in the code above: - A mod object is created (in the Overlay Pattern) - The NPC group's records are iterated over - Using typical C# LINQ patterns, <code>Name</code> is selected and filtered out if empty or duplicates - Each name is printed out to the console - The mod object is disposed as we exit the <code>using</code> statement, which closes out any open file streams</p> <p>This code is self-sufficient, aside from needing to supply the desired <code>pathToMod</code> to open.  No other bootstrap code or other frameworking is required.</p>"},{"location":"familiar/Namespaces/","title":"Namespaces","text":""},{"location":"familiar/Namespaces/#what-are-namespaces","title":"What Are Namespaces","text":"<p>Namespaces are \"sections\" of code that you can opt to import so that you have access to.  They help organize things and prevent naming collisions.   </p> <p>They typically might look like: <pre><code>// Import the namespace\nusing Mutagen.Bethesda.Skyrim;\n\n// Now I have access to the SkyrimMod concepts\nvar skyrimMod = new SkyrimMod(\"Skyrim.esm\", SkyrimRelease.SkyrimSE);\n</code></pre></p>"},{"location":"familiar/Namespaces/#namespaces-intellisense-and-compiling","title":"Namespaces, Intellisense, and Compiling","text":"<p>By default, Visual Studio will only show autocomplete for the concepts that exist within the namespaces you have imported.  </p> <p>If you have an empty file and start typing <code>SkyrimMod</code>, it will not autocomplete.  If you type the whole thing out manually, it'll be underlined red saying it does not know what it is.  This is because the namespace is not imported, and so it's not showing you SkyrimMod as an option to use.</p>"},{"location":"familiar/Namespaces/#adding-a-namespace","title":"Adding a Namespace","text":"<p>Often you want to add a namespace so that the compiler knows about it, and Intellisense shows it in autocomplete.</p>"},{"location":"familiar/Namespaces/#add-the-namespace-import-yourself","title":"Add the Namespace Import Yourself","text":"<p>You can write it out yourself by adding it to the top of your file: <pre><code>using Mutagen.Bethesda.Skyrim;\n\nvar skyrimMod = new SkyrimMod(\"Skyrim.esm\", SkyrimRelease.SkyrimSE);\n</code></pre></p> <p>This has the downside that you need to know what the namespace that you're interested in is</p>"},{"location":"familiar/Namespaces/#let-the-ide-add-the-namespace","title":"Let the IDE add the Namespace","text":"<p>Alternatively, if you know the thing you would like to use, you can write it out, and have the IDE find out what namespace needs to be imported for you.</p> <p>For example, you could type out <code>SkyrimMod</code>, and when it highlights red, do the Visual Studio keybind for suggest fixes (Ctrl + .) and it will suggest adding <code>Mutagen.Bethesda.Skyrim</code> to your namespaces.  Select that option, and the IDE will go ahead and do that.</p> <p>This still has the downside that you need to know what type you are interested in using and type it out by hand.  In our case that was <code>SkyrimMod</code>.  This is vulnerable to typos where the IDE wont be able to locate the namespace if it's misspelled, etc.</p>"},{"location":"familiar/Namespaces/#show-types-from-other-namespaces-in-intellisense","title":"Show Types From Other Namespaces in Intellisense","text":"<p>The final option is to allow Intellisense to show in its autocomplete ALL types that exist, not just the ones from namespaces you have imported.   This is often super nice, as you can then just start typing in <code>SkyrimMod</code> and it will show it as an autocomplete option.  If you choose to autocomplete it, it will automatically add the necessary namespace, too.</p> <p>This is by far the easiest usability, but of course comes with the downside of having a more \"clogged\" Intellisense since it is always showing all the types in existence.   Usually, though, this is not too much of a problem, as the IDE is able to narrow things down and suggest items pretty intelligently.</p> <p>To turn this on, you need to go into your <code>Visual Studio</code> options:</p> <p><code>Visual Studio -&gt; Top Bar -&gt; Tools -&gt; Options -&gt; Text Editor -&gt; C# -&gt; Intellisense -&gt; Show items from unimported namespaces</code></p> <p></p> <p><code>Rider</code> has this functionality on by default.</p>"},{"location":"familiar/Namespaces/#namespaces-help-with-collisions","title":"Namespaces Help With Collisions","text":"<p>In addition to \"scoping\" Intellisense as mentioned above, namespaces also help when you have a legitimate name collision.   Let's say you're using two libraries that both defined <code>MyClass</code>, and you want to use both of them in the same code snippet.  How do you do this? <pre><code>var classA = new SomeLibrary.MyClass();\nvar classB = new OtherLibrary.MyClass();\n</code></pre> The above snippet shows that you can include the namespace to help specify which <code>MyClass</code> you're referring to, and so both can be used side by side, despite the bad naming.</p>"},{"location":"familiar/Nullability-to-Indicate-Record-Presence/","title":"Nullability to Indicate Record Presence","text":""},{"location":"familiar/Nullability-to-Indicate-Record-Presence/#most-subrecords-are-optional","title":"Most Subrecords are Optional","text":"<p>Most Bethesda subrecords are optional; They can be set to a value, or not exist at all.  Mutagen uses a field's nullability to indicate which fields/subrecords are optional.   This leverages one of C#'s newer concepts of Nullable References.</p> <p>TLDR: Fields can be marked as to whether they are allowed to be null or not: <pre><code>string RequiredField { get; set; }\nstring? OptionalField { get; set; }\n</code></pre></p> <p>The <code>RequiredField</code> cannot be <code>null</code>, and always must have some value.  The <code>OptionalField</code> is allowed to be <code>null</code>.  Mutagen utilizes this distinction to communicate that <code>OptionalField</code> is considered \"unset\" if/when it is <code>null</code>.</p> <p>Going off the earlier <code>Potion</code> interface: - FormKey cannot be null, and must always have a value. - EditorID, Name, Model, Icon are all optional, and will be null if they are not set.</p>"},{"location":"familiar/Nullability-to-Indicate-Record-Presence/#dealing-with-nullable-fields","title":"Dealing with Nullable Fields","text":"<p>In recent C#, the compiler will error out if you're trying to access or use a value that might be null without ensuring it is not null first.  When a field is nullable, you will want to adjust your code to deal with the potential that it might not exist.</p>"},{"location":"familiar/Nullability-to-Indicate-Record-Presence/#dont-check-unless-needed","title":"Don't Check Unless Needed","text":"<p>Not all fields are nullable.  If a field's type does not end with a <code>?</code> then it cannot be null and thus does not need to be checked.</p> <p>Checking if a non-nullable field is null is unnecessary, and actually confuses the compiler in certain circumstances.  Typically the compiler will let you know when something hasn't been checked by giving you an error.  You can usually wait until it complains before worrying about writing null checks.  </p>"},{"location":"familiar/Nullability-to-Indicate-Record-Presence/#skipping-if-null","title":"Skipping if null","text":"<p>If you're within a foreach loop you can opt to skip the record if the field you're interested in is null: <pre><code>IObjectEffect objectEffect = ...;\nforeach (var effect in objectEffect.Effects)\n{\nif (effect.Data == null) continue;\nConsole.WriteLine($\"Magnitude was: {effect.Data.Magnitude}\");\n}\n</code></pre></p>"},{"location":"familiar/Nullability-to-Indicate-Record-Presence/#using-a-fallback-value-if-null","title":"Using a fallback value if null","text":"<p>You can also use Null Conditional Operators to help specify \"fallback\" values if a field is null <pre><code>IObjectEffect objectEffect = ...;\nforeach (var effect in objectEffect.Effects)\n{\n// This will be set to -1 if Data is null\nvar magnitude = effect.Data?.Magnitude ?? -1;\nConsole.WriteLine($\"Magnitude was: {magnitude}\");\n}\n</code></pre></p>"},{"location":"familiar/Nullability-to-Indicate-Record-Presence/#setting-the-null-field-to-have-a-value","title":"Setting the null field to have a value","text":"<p>Sometimes when you're creating a record, you might need to create the subclasses yourself on the nullable fields so that you can fill them. <pre><code>IObjectEffect objectEffect = ...;\nforeach (var effect in objectEffect.Effects)\n{\n// A fancy way of setting the field to a new EffectData if it's null\neffect.Data ??= new EffectData();\n\n// And now we can set its Magnitude knowing it will never be null\neffect.Data.Magnitude = 100;\n}\n</code></pre></p>"},{"location":"familiar/Nullability-to-Indicate-Record-Presence/#other","title":"Other","text":"<p>There are many other ways to deal with the potential of null values besides the examples given, depending on the circumstances and goals.</p>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/","title":"Oblivion Aspect Interfaces","text":""},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#aspect-interfaces","title":"Aspect Interfaces","text":"<p>Aspect Interfaces expose common aspects of records.  For example, <code>INamed</code> are implemented by all records that have a <code>Name</code>.</p> <p>Functions can then be written that take in <code>INamed</code>, allowing any record that has a name to be passed in.</p>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#interfaces-to-concrete-classes","title":"Interfaces to Concrete Classes","text":""},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#imodeled","title":"IModeled","text":"<ul> <li>Activator</li> <li>AlchemicalApparatus</li> <li>Ammunition</li> <li>AnimatedObject</li> <li>BodyData</li> <li>Book</li> <li>Climate</li> <li>Container</li> <li>Creature</li> <li>Door</li> <li>FacePart</li> <li>Flora</li> <li>Furniture</li> <li>Grass</li> <li>Hair</li> <li>IdleAnimation</li> <li>Ingredient</li> <li>Key</li> <li>Light</li> <li>MagicEffect</li> <li>Miscellaneous</li> <li>Npc</li> <li>Potion</li> <li>SigilStone</li> <li>SoulGem</li> <li>Static</li> <li>Tree</li> <li>Weapon</li> <li>Weather</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#inamed","title":"INamed","text":"<ul> <li>AClothing</li> <li>Activator</li> <li>AlchemicalApparatus</li> <li>Ammunition</li> <li>Armor</li> <li>Birthsign</li> <li>Book</li> <li>Cell</li> <li>Class</li> <li>Clothing</li> <li>Container</li> <li>Creature</li> <li>DialogTopic</li> <li>Door</li> <li>Enchantment</li> <li>Eye</li> <li>Faction</li> <li>Flora</li> <li>Furniture</li> <li>Hair</li> <li>Ingredient</li> <li>Key</li> <li>Light</li> <li>LocalVariable</li> <li>MagicEffect</li> <li>MapMarker</li> <li>Miscellaneous</li> <li>Npc</li> <li>Potion</li> <li>Quest</li> <li>Race</li> <li>ScriptEffect</li> <li>SigilStone</li> <li>SoulGem</li> <li>Spell</li> <li>SpellLeveled</li> <li>SpellUnleveled</li> <li>Weapon</li> <li>Worldspace</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#iweightvalue","title":"IWeightValue","text":"<ul> <li>AlchemicalApparatusData</li> <li>AmmunitionData</li> <li>ArmorData</li> <li>ClothingData</li> <li>KeyData</li> <li>LightData</li> <li>SigilStoneData</li> <li>SoulGemData</li> <li>WeaponData</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#concrete-classes-to-interfaces","title":"Concrete Classes to Interfaces","text":""},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#aclothing","title":"AClothing","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#activator","title":"Activator","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#alchemicalapparatus","title":"AlchemicalApparatus","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#alchemicalapparatusdata","title":"AlchemicalApparatusData","text":"<ul> <li>IWeightValue</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#ammunition","title":"Ammunition","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#ammunitiondata","title":"AmmunitionData","text":"<ul> <li>IWeightValue</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#animatedobject","title":"AnimatedObject","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#armor","title":"Armor","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#armordata","title":"ArmorData","text":"<ul> <li>IWeightValue</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#birthsign","title":"Birthsign","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#bodydata","title":"BodyData","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#book","title":"Book","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#cell","title":"Cell","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#class","title":"Class","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#climate","title":"Climate","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#clothing","title":"Clothing","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#clothingdata","title":"ClothingData","text":"<ul> <li>IWeightValue</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#container","title":"Container","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#creature","title":"Creature","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#dialogtopic","title":"DialogTopic","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#door","title":"Door","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#enchantment","title":"Enchantment","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#eye","title":"Eye","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#facepart","title":"FacePart","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#faction","title":"Faction","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#flora","title":"Flora","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#furniture","title":"Furniture","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#grass","title":"Grass","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#hair","title":"Hair","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#idleanimation","title":"IdleAnimation","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#ingredient","title":"Ingredient","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#key","title":"Key","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#keydata","title":"KeyData","text":"<ul> <li>IWeightValue</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#light","title":"Light","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#lightdata","title":"LightData","text":"<ul> <li>IWeightValue</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#localvariable","title":"LocalVariable","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#magiceffect","title":"MagicEffect","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#mapmarker","title":"MapMarker","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#miscellaneous","title":"Miscellaneous","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#npc","title":"Npc","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#potion","title":"Potion","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#quest","title":"Quest","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#race","title":"Race","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#scripteffect","title":"ScriptEffect","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#sigilstone","title":"SigilStone","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#sigilstonedata","title":"SigilStoneData","text":"<ul> <li>IWeightValue</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#soulgem","title":"SoulGem","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#soulgemdata","title":"SoulGemData","text":"<ul> <li>IWeightValue</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#spell","title":"Spell","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#spellleveled","title":"SpellLeveled","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#spellunleveled","title":"SpellUnleveled","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#static","title":"Static","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#tree","title":"Tree","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#weapon","title":"Weapon","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#weapondata","title":"WeaponData","text":"<ul> <li>IWeightValue</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#weather","title":"Weather","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#worldspace","title":"Worldspace","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Link-Interfaces/","title":"Oblivion Link Interfaces","text":""},{"location":"game-specific/oblivion/Oblivion-Link-Interfaces/#link-interfaces","title":"Link Interfaces","text":"<p>Link Interfaces are used by FormLinks to point to several record types at once.  For example, a Container record might be able to contain Armors, Weapons, Ingredients, etc.</p> <p>An interface would be defined such as 'IItem', which all Armor, Weapon, Ingredients would all implement.</p> <p>A <code>FormLink&lt;IItem&gt;</code> could then point to all those record types by pointing to the interface instead.</p>"},{"location":"game-specific/oblivion/Oblivion-Link-Interfaces/#interfaces-to-concrete-classes","title":"Interfaces to Concrete Classes","text":""},{"location":"game-specific/oblivion/Oblivion-Link-Interfaces/#iowner","title":"IOwner","text":"<ul> <li>Faction</li> <li>Npc</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Link-Interfaces/#iplaced","title":"IPlaced","text":"<ul> <li>Landscape</li> <li>PlacedCreature</li> <li>PlacedNpc</li> <li>PlacedObject</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Link-Interfaces/#concrete-classes-to-interfaces","title":"Concrete Classes to Interfaces","text":""},{"location":"game-specific/oblivion/Oblivion-Link-Interfaces/#faction","title":"Faction","text":"<ul> <li>IOwner</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Link-Interfaces/#landscape","title":"Landscape","text":"<ul> <li>IPlaced</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Link-Interfaces/#npc","title":"Npc","text":"<ul> <li>IOwner</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Link-Interfaces/#placedcreature","title":"PlacedCreature","text":"<ul> <li>IPlaced</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Link-Interfaces/#placednpc","title":"PlacedNpc","text":"<ul> <li>IPlaced</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Link-Interfaces/#placedobject","title":"PlacedObject","text":"<ul> <li>IPlaced</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/","title":"Skyrim Aspect Interfaces","text":""},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#aspect-interfaces","title":"Aspect Interfaces","text":"<p>Aspect Interfaces expose common aspects of records.  For example, <code>INamed</code> are implemented by all records that have a <code>Name</code>.</p> <p>Functions can then be written that take in <code>INamed</code>, allowing any record that has a name to be passed in.</p>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#interfaces-to-concrete-classes","title":"Interfaces to Concrete Classes","text":""},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#ihasicons","title":"IHasIcons","text":"<ul> <li>AlchemicalApparatus</li> <li>Ammunition</li> <li>ArmorModel</li> <li>Book</li> <li>Ingestible</li> <li>Ingredient</li> <li>Key</li> <li>Light</li> <li>LoadScreen</li> <li>MiscItem</li> <li>Perk</li> <li>RegionData</li> <li>SoulGem</li> <li>Weapon</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#ikeyworded","title":"IKeyworded","text":"<ul> <li>Activator</li> <li>Ammunition</li> <li>Armor</li> <li>Book</li> <li>Flora</li> <li>Furniture</li> <li>Ingestible</li> <li>Ingredient</li> <li>Key</li> <li>Location</li> <li>MagicEffect</li> <li>MiscItem</li> <li>Npc</li> <li>QuestAlias</li> <li>Race</li> <li>Scroll</li> <li>SoulGem</li> <li>Spell</li> <li>TalkingActivator</li> <li>Weapon</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#imodeled","title":"IModeled","text":"<ul> <li>Activator</li> <li>AddonNode</li> <li>AlchemicalApparatus</li> <li>Ammunition</li> <li>AnimatedObject</li> <li>ArmorModel</li> <li>ArtObject</li> <li>BodyData</li> <li>BodyPartData</li> <li>Book</li> <li>CameraShot</li> <li>Climate</li> <li>Container</li> <li>DestructionStage</li> <li>Door</li> <li>Explosion</li> <li>Flora</li> <li>Furniture</li> <li>Grass</li> <li>Hazard</li> <li>HeadData</li> <li>HeadPart</li> <li>IdleMarker</li> <li>Impact</li> <li>Ingestible</li> <li>Ingredient</li> <li>Key</li> <li>LeveledNpc</li> <li>Light</li> <li>MaterialObject</li> <li>MiscItem</li> <li>MoveableStatic</li> <li>Projectile</li> <li>Scroll</li> <li>SoulGem</li> <li>Static</li> <li>TalkingActivator</li> <li>Tree</li> <li>Weapon</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#inamed","title":"INamed","text":"<ul> <li>Activator</li> <li>ActorValueInformation</li> <li>AlchemicalApparatus</li> <li>AlternateTexture</li> <li>Ammunition</li> <li>APackageData</li> <li>Armor</li> <li>BodyPart</li> <li>Book</li> <li>Cell</li> <li>Class</li> <li>CollisionLayer</li> <li>ColorRecord</li> <li>Container</li> <li>DialogTopic</li> <li>Door</li> <li>Explosion</li> <li>Eyes</li> <li>Faction</li> <li>Flora</li> <li>Furniture</li> <li>Hazard</li> <li>HeadPart</li> <li>Ingestible</li> <li>Ingredient</li> <li>Key</li> <li>Light</li> <li>Location</li> <li>MagicEffect</li> <li>MapMarker</li> <li>MaterialType</li> <li>Message</li> <li>MiscItem</li> <li>MoveableStatic</li> <li>MovementType</li> <li>Npc</li> <li>ObjectEffect</li> <li>PackageDataBool</li> <li>PackageDataFloat</li> <li>PackageDataInt</li> <li>PackageDataLocation</li> <li>PackageDataObjectList</li> <li>PackageDataTarget</li> <li>PackageDataTopic</li> <li>Perk</li> <li>Phoneme</li> <li>Projectile</li> <li>Quest</li> <li>QuestAlias</li> <li>Race</li> <li>RegionMap</li> <li>SceneAction</li> <li>ScenePhase</li> <li>ScriptBoolListProperty</li> <li>ScriptBoolProperty</li> <li>ScriptEntry</li> <li>ScriptFloatListProperty</li> <li>ScriptFloatProperty</li> <li>ScriptIntListProperty</li> <li>ScriptIntProperty</li> <li>ScriptObjectListProperty</li> <li>ScriptObjectProperty</li> <li>ScriptProperty</li> <li>ScriptStringListProperty</li> <li>ScriptStringProperty</li> <li>Scroll</li> <li>Shout</li> <li>SoulGem</li> <li>SoundCategory</li> <li>Spell</li> <li>TalkingActivator</li> <li>Tree</li> <li>Water</li> <li>Weapon</li> <li>WordOfPower</li> <li>Worldspace</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#iobjectbounded","title":"IObjectBounded","text":"<ul> <li>AcousticSpace</li> <li>Activator</li> <li>AddonNode</li> <li>AlchemicalApparatus</li> <li>Ammunition</li> <li>Armor</li> <li>ArtObject</li> <li>Book</li> <li>Container</li> <li>Door</li> <li>DualCastData</li> <li>Explosion</li> <li>Flora</li> <li>Furniture</li> <li>Grass</li> <li>Hazard</li> <li>IdleMarker</li> <li>Ingestible</li> <li>Ingredient</li> <li>Key</li> <li>LeveledItem</li> <li>LeveledNpc</li> <li>LeveledSpell</li> <li>Light</li> <li>MiscItem</li> <li>MoveableStatic</li> <li>Npc</li> <li>ObjectEffect</li> <li>Projectile</li> <li>Scroll</li> <li>SoulGem</li> <li>SoundMarker</li> <li>Spell</li> <li>Static</li> <li>TalkingActivator</li> <li>TextureSet</li> <li>Tree</li> <li>Weapon</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#iweightvalue","title":"IWeightValue","text":"<ul> <li>AlchemicalApparatus</li> <li>Ammunition</li> <li>Armor</li> <li>Book</li> <li>Ingestible</li> <li>Ingredient</li> <li>Key</li> <li>Light</li> <li>MiscItem</li> <li>Scroll</li> <li>SoulGem</li> <li>WeaponBasicStats</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#keyword","title":"Keyword","text":"<ul> <li>Keyword</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#concrete-classes-to-interfaces","title":"Concrete Classes to Interfaces","text":""},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#acousticspace","title":"AcousticSpace","text":"<ul> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#activator","title":"Activator","text":"<ul> <li>IKeyworded</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#actorvalueinformation","title":"ActorValueInformation","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#addonnode","title":"AddonNode","text":"<ul> <li>IModeled</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#alchemicalapparatus","title":"AlchemicalApparatus","text":"<ul> <li>IHasIcons</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> <li>IWeightValue</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#alternatetexture","title":"AlternateTexture","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#ammunition","title":"Ammunition","text":"<ul> <li>IHasIcons</li> <li>IKeyworded</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> <li>IWeightValue</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#animatedobject","title":"AnimatedObject","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#apackagedata","title":"APackageData","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#armor","title":"Armor","text":"<ul> <li>IKeyworded</li> <li>INamed</li> <li>IObjectBounded</li> <li>IWeightValue</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#armormodel","title":"ArmorModel","text":"<ul> <li>IHasIcons</li> <li>IModeled</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#artobject","title":"ArtObject","text":"<ul> <li>IModeled</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#bodydata","title":"BodyData","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#bodypart","title":"BodyPart","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#bodypartdata","title":"BodyPartData","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#book","title":"Book","text":"<ul> <li>IHasIcons</li> <li>IKeyworded</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> <li>IWeightValue</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#camerashot","title":"CameraShot","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#cell","title":"Cell","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#class","title":"Class","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#climate","title":"Climate","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#collisionlayer","title":"CollisionLayer","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#colorrecord","title":"ColorRecord","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#container","title":"Container","text":"<ul> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#destructionstage","title":"DestructionStage","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#dialogtopic","title":"DialogTopic","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#door","title":"Door","text":"<ul> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#dualcastdata","title":"DualCastData","text":"<ul> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#explosion","title":"Explosion","text":"<ul> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#eyes","title":"Eyes","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#faction","title":"Faction","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#flora","title":"Flora","text":"<ul> <li>IKeyworded</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#furniture","title":"Furniture","text":"<ul> <li>IKeyworded</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#grass","title":"Grass","text":"<ul> <li>IModeled</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#hazard","title":"Hazard","text":"<ul> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#headdata","title":"HeadData","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#headpart","title":"HeadPart","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#idlemarker","title":"IdleMarker","text":"<ul> <li>IModeled</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#impact","title":"Impact","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#ingestible","title":"Ingestible","text":"<ul> <li>IHasIcons</li> <li>IKeyworded</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> <li>IWeightValue</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#ingredient","title":"Ingredient","text":"<ul> <li>IHasIcons</li> <li>IKeyworded</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> <li>IWeightValue</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#key","title":"Key","text":"<ul> <li>IHasIcons</li> <li>IKeyworded</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> <li>IWeightValue</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#keyword_1","title":"Keyword","text":"<ul> <li>Keyword</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#leveleditem","title":"LeveledItem","text":"<ul> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#levelednpc","title":"LeveledNpc","text":"<ul> <li>IModeled</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#leveledspell","title":"LeveledSpell","text":"<ul> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#light","title":"Light","text":"<ul> <li>IHasIcons</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> <li>IWeightValue</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#loadscreen","title":"LoadScreen","text":"<ul> <li>IHasIcons</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#location","title":"Location","text":"<ul> <li>IKeyworded</li> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#magiceffect","title":"MagicEffect","text":"<ul> <li>IKeyworded</li> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#mapmarker","title":"MapMarker","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#materialobject","title":"MaterialObject","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#materialtype","title":"MaterialType","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#message","title":"Message","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#miscitem","title":"MiscItem","text":"<ul> <li>IHasIcons</li> <li>IKeyworded</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> <li>IWeightValue</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#moveablestatic","title":"MoveableStatic","text":"<ul> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#movementtype","title":"MovementType","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#npc","title":"Npc","text":"<ul> <li>IKeyworded</li> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#objecteffect","title":"ObjectEffect","text":"<ul> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#packagedatabool","title":"PackageDataBool","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#packagedatafloat","title":"PackageDataFloat","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#packagedataint","title":"PackageDataInt","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#packagedatalocation","title":"PackageDataLocation","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#packagedataobjectlist","title":"PackageDataObjectList","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#packagedatatarget","title":"PackageDataTarget","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#packagedatatopic","title":"PackageDataTopic","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#perk","title":"Perk","text":"<ul> <li>IHasIcons</li> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#phoneme","title":"Phoneme","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#projectile","title":"Projectile","text":"<ul> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#quest","title":"Quest","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#questalias","title":"QuestAlias","text":"<ul> <li>IKeyworded</li> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#race","title":"Race","text":"<ul> <li>IKeyworded</li> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#regiondata","title":"RegionData","text":"<ul> <li>IHasIcons</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#regionmap","title":"RegionMap","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#sceneaction","title":"SceneAction","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#scenephase","title":"ScenePhase","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#scriptboollistproperty","title":"ScriptBoolListProperty","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#scriptboolproperty","title":"ScriptBoolProperty","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#scriptentry","title":"ScriptEntry","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#scriptfloatlistproperty","title":"ScriptFloatListProperty","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#scriptfloatproperty","title":"ScriptFloatProperty","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#scriptintlistproperty","title":"ScriptIntListProperty","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#scriptintproperty","title":"ScriptIntProperty","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#scriptobjectlistproperty","title":"ScriptObjectListProperty","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#scriptobjectproperty","title":"ScriptObjectProperty","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#scriptproperty","title":"ScriptProperty","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#scriptstringlistproperty","title":"ScriptStringListProperty","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#scriptstringproperty","title":"ScriptStringProperty","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#scroll","title":"Scroll","text":"<ul> <li>IKeyworded</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> <li>IWeightValue</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#shout","title":"Shout","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#soulgem","title":"SoulGem","text":"<ul> <li>IHasIcons</li> <li>IKeyworded</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> <li>IWeightValue</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#soundcategory","title":"SoundCategory","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#soundmarker","title":"SoundMarker","text":"<ul> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#spell","title":"Spell","text":"<ul> <li>IKeyworded</li> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#static","title":"Static","text":"<ul> <li>IModeled</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#talkingactivator","title":"TalkingActivator","text":"<ul> <li>IKeyworded</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#textureset","title":"TextureSet","text":"<ul> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#tree","title":"Tree","text":"<ul> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#water","title":"Water","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#weapon","title":"Weapon","text":"<ul> <li>IHasIcons</li> <li>IKeyworded</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#weaponbasicstats","title":"WeaponBasicStats","text":"<ul> <li>IWeightValue</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#wordofpower","title":"WordOfPower","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#worldspace","title":"Worldspace","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/","title":"Skyrim Link Interfaces","text":""},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#link-interfaces","title":"Link Interfaces","text":"<p>Link Interfaces are used by FormLinks to point to several record types at once.  For example, a Container record might be able to contain Armors, Weapons, Ingredients, etc.</p> <p>An interface would be defined such as 'IItem', which all Armor, Weapon, Ingredients would all implement.</p> <p>A <code>FormLink&lt;IItem&gt;</code> could then point to all those record types by pointing to the interface instead.</p>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#interfaces-to-concrete-classes","title":"Interfaces to Concrete Classes","text":""},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#ialiasvoicetype","title":"IAliasVoiceType","text":"<ul> <li>FormList</li> <li>Npc</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#icomplexlocation","title":"IComplexLocation","text":"<ul> <li>Cell</li> <li>Worldspace</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#iconstructible","title":"IConstructible","text":"<ul> <li>AlchemicalApparatus</li> <li>Ammunition</li> <li>Armor</li> <li>Book</li> <li>Ingestible</li> <li>Ingredient</li> <li>Key</li> <li>Light</li> <li>MiscItem</li> <li>Scroll</li> <li>SoulGem</li> <li>Weapon</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#idialog","title":"IDialog","text":"<ul> <li>DialogResponses</li> <li>DialogTopic</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#ieffectrecord","title":"IEffectRecord","text":"<ul> <li>ObjectEffect</li> <li>Spell</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#iemittance","title":"IEmittance","text":"<ul> <li>Light</li> <li>Region</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#iharvesttarget","title":"IHarvestTarget","text":"<ul> <li>Ingestible</li> <li>Ingredient</li> <li>LeveledItem</li> <li>MiscItem</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#iidlerelation","title":"IIdleRelation","text":"<ul> <li>ActionRecord</li> <li>IdleAnimation</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#iitem","title":"IItem","text":"<ul> <li>AlchemicalApparatus</li> <li>Ammunition</li> <li>Armor</li> <li>Book</li> <li>Ingestible</li> <li>Ingredient</li> <li>Key</li> <li>LeveledItem</li> <li>Light</li> <li>MiscItem</li> <li>Scroll</li> <li>SoulGem</li> <li>Weapon</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#ikeywordlinkedreference","title":"IKeywordLinkedReference","text":"<ul> <li>APlacedTrap</li> <li>Keyword</li> <li>PlacedNpc</li> <li>PlacedObject</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#ilinkedreference","title":"ILinkedReference","text":"<ul> <li>APlacedTrap</li> <li>PlacedNpc</li> <li>PlacedObject</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#ilocationrecord","title":"ILocationRecord","text":"<ul> <li>Location</li> <li>LocationReferenceType</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#ilocationtargetable","title":"ILocationTargetable","text":"<ul> <li>Door</li> <li>PlacedNpc</li> <li>PlacedObject</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#ilocklist","title":"ILockList","text":"<ul> <li>FormList</li> <li>Npc</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#inpcspawn","title":"INpcSpawn","text":"<ul> <li>LeveledNpc</li> <li>Npc</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#iobjectid","title":"IObjectId","text":"<ul> <li>Activator</li> <li>Ammunition</li> <li>Armor</li> <li>Book</li> <li>Container</li> <li>Door</li> <li>Faction</li> <li>FormList</li> <li>Furniture</li> <li>IdleMarker</li> <li>Ingestible</li> <li>Key</li> <li>Light</li> <li>MiscItem</li> <li>MoveableStatic</li> <li>Npc</li> <li>Projectile</li> <li>Scroll</li> <li>Shout</li> <li>SoundMarker</li> <li>Spell</li> <li>Static</li> <li>TextureSet</li> <li>Weapon</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#ioutfittarget","title":"IOutfitTarget","text":"<ul> <li>Armor</li> <li>LeveledItem</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#iowner","title":"IOwner","text":"<ul> <li>Faction</li> <li>PlacedNpc</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#iplaced","title":"IPlaced","text":"<ul> <li>APlaced</li> <li>APlacedTrap</li> <li>PlacedNpc</li> <li>PlacedObject</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#iplacedsimple","title":"IPlacedSimple","text":"<ul> <li>PlacedNpc</li> <li>PlacedObject</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#iplacedthing","title":"IPlacedThing","text":"<ul> <li>APlacedTrap</li> <li>PlacedObject</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#iplacedtraptarget","title":"IPlacedTrapTarget","text":"<ul> <li>Hazard</li> <li>Projectile</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#iregiontarget","title":"IRegionTarget","text":"<ul> <li>Flora</li> <li>LandscapeTexture</li> <li>MoveableStatic</li> <li>Static</li> <li>Tree</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#irelatable","title":"IRelatable","text":"<ul> <li>Faction</li> <li>Race</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#isound","title":"ISound","text":"<ul> <li>SoundDescriptor</li> <li>SoundMarker</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#ispellspawn","title":"ISpellSpawn","text":"<ul> <li>LeveledSpell</li> <li>Spell</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#concrete-classes-to-interfaces","title":"Concrete Classes to Interfaces","text":""},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#actionrecord","title":"ActionRecord","text":"<ul> <li>IIdleRelation</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#activator","title":"Activator","text":"<ul> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#alchemicalapparatus","title":"AlchemicalApparatus","text":"<ul> <li>IConstructible</li> <li>IItem</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#ammunition","title":"Ammunition","text":"<ul> <li>IConstructible</li> <li>IItem</li> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#aplaced","title":"APlaced","text":"<ul> <li>IPlaced</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#aplacedtrap","title":"APlacedTrap","text":"<ul> <li>IKeywordLinkedReference</li> <li>ILinkedReference</li> <li>IPlaced</li> <li>IPlacedThing</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#armor","title":"Armor","text":"<ul> <li>IConstructible</li> <li>IItem</li> <li>IObjectId</li> <li>IOutfitTarget</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#book","title":"Book","text":"<ul> <li>IConstructible</li> <li>IItem</li> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#cell","title":"Cell","text":"<ul> <li>IComplexLocation</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#container","title":"Container","text":"<ul> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#dialogresponses","title":"DialogResponses","text":"<ul> <li>IDialog</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#dialogtopic","title":"DialogTopic","text":"<ul> <li>IDialog</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#door","title":"Door","text":"<ul> <li>ILocationTargetable</li> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#faction","title":"Faction","text":"<ul> <li>IObjectId</li> <li>IOwner</li> <li>IRelatable</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#flora","title":"Flora","text":"<ul> <li>IRegionTarget</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#formlist","title":"FormList","text":"<ul> <li>IAliasVoiceType</li> <li>ILockList</li> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#furniture","title":"Furniture","text":"<ul> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#hazard","title":"Hazard","text":"<ul> <li>IPlacedTrapTarget</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#idleanimation","title":"IdleAnimation","text":"<ul> <li>IIdleRelation</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#idlemarker","title":"IdleMarker","text":"<ul> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#ingestible","title":"Ingestible","text":"<ul> <li>IConstructible</li> <li>IHarvestTarget</li> <li>IItem</li> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#ingredient","title":"Ingredient","text":"<ul> <li>IConstructible</li> <li>IHarvestTarget</li> <li>IItem</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#key","title":"Key","text":"<ul> <li>IConstructible</li> <li>IItem</li> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#keyword","title":"Keyword","text":"<ul> <li>IKeywordLinkedReference</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#landscapetexture","title":"LandscapeTexture","text":"<ul> <li>IRegionTarget</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#leveleditem","title":"LeveledItem","text":"<ul> <li>IHarvestTarget</li> <li>IItem</li> <li>IOutfitTarget</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#levelednpc","title":"LeveledNpc","text":"<ul> <li>INpcSpawn</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#leveledspell","title":"LeveledSpell","text":"<ul> <li>ISpellSpawn</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#light","title":"Light","text":"<ul> <li>IConstructible</li> <li>IEmittance</li> <li>IItem</li> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#location","title":"Location","text":"<ul> <li>ILocationRecord</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#locationreferencetype","title":"LocationReferenceType","text":"<ul> <li>ILocationRecord</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#miscitem","title":"MiscItem","text":"<ul> <li>IConstructible</li> <li>IHarvestTarget</li> <li>IItem</li> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#moveablestatic","title":"MoveableStatic","text":"<ul> <li>IObjectId</li> <li>IRegionTarget</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#npc","title":"Npc","text":"<ul> <li>IAliasVoiceType</li> <li>ILockList</li> <li>INpcSpawn</li> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#objecteffect","title":"ObjectEffect","text":"<ul> <li>IEffectRecord</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#placednpc","title":"PlacedNpc","text":"<ul> <li>IKeywordLinkedReference</li> <li>ILinkedReference</li> <li>ILocationTargetable</li> <li>IOwner</li> <li>IPlaced</li> <li>IPlacedSimple</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#placedobject","title":"PlacedObject","text":"<ul> <li>IKeywordLinkedReference</li> <li>ILinkedReference</li> <li>ILocationTargetable</li> <li>IPlaced</li> <li>IPlacedSimple</li> <li>IPlacedThing</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#projectile","title":"Projectile","text":"<ul> <li>IObjectId</li> <li>IPlacedTrapTarget</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#race","title":"Race","text":"<ul> <li>IRelatable</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#region","title":"Region","text":"<ul> <li>IEmittance</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#scroll","title":"Scroll","text":"<ul> <li>IConstructible</li> <li>IItem</li> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#shout","title":"Shout","text":"<ul> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#soulgem","title":"SoulGem","text":"<ul> <li>IConstructible</li> <li>IItem</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#sounddescriptor","title":"SoundDescriptor","text":"<ul> <li>ISound</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#soundmarker","title":"SoundMarker","text":"<ul> <li>IObjectId</li> <li>ISound</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#spell","title":"Spell","text":"<ul> <li>IEffectRecord</li> <li>IObjectId</li> <li>ISpellSpawn</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#static","title":"Static","text":"<ul> <li>IObjectId</li> <li>IRegionTarget</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#textureset","title":"TextureSet","text":"<ul> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#tree","title":"Tree","text":"<ul> <li>IRegionTarget</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#weapon","title":"Weapon","text":"<ul> <li>IConstructible</li> <li>IItem</li> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#worldspace","title":"Worldspace","text":"<ul> <li>IComplexLocation</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Perks/","title":"Skyrim Perks","text":""},{"location":"game-specific/skyrim/Skyrim-Perks/#perk-effect-types","title":"Perk Effect Types","text":"<p>The abstract base class is <code>APerkEffect</code> which is inherited by: - <code>PerkQuestEffect</code> - <code>PerkAbilityEffect</code> - <code>APerkEntryPointEffect</code></p>"},{"location":"game-specific/skyrim/Skyrim-Perks/#perk-entry-point-effect-types","title":"Perk Entry Point Effect Types","text":"<p>The abstract base class is <code>APerkEntryPointEffect</code> which is inherited by: - <code>PerkModifyValue</code> - <code>PerkAddRangeToValue</code> - <code>PerkModifyActorValue</code> - <code>PerkAbsoluteValue</code> - <code>PerkAddLeveledItem</code> - <code>PerkAddActivateChoice</code> - <code>PerkSelectSpell</code> - <code>PerkSelectText</code> - <code>PerkSetText</code></p>"},{"location":"linkcache/","title":"Link Cache","text":"<p>The LinkCache is the record lookup engine.  It powers a lot of functionality, such as: - Looking up records by FormKey/FormLink - Finding the Winning Override in a Load Order - Iterating over all versions of a record within a Load Order</p>"},{"location":"linkcache/#context","title":"Context","text":"<p>Every LinkCache is created from a context: - A single mod - A Load Order - Any arbitrary enumeration of mods</p> <pre><code>// Can attach to a single mod\nISkyrimModGetter aSingleMod = ...;\nvar linkCacheConnectedToMod = aSingleMod.ToImmutableLinkCache();\n\n// Or a load order of mods\nILoadOrderGetter&lt;ISkyrimModGetter&gt; someLoadOrder = ...;\nvar linkCacheConnectedToLoadOrder = someLoadOrder.ToImmutableLinkCache();\n\n// Or any random list of mods you provide\nIEnumerable&lt;ISkyrimModGetter&gt; anyListOfMods = ...;\nvar linkCacheConnectedToThoseMods = anyListOfMods.ToImmutableLinkCache();\n</code></pre> <p>Each of the above link caches will look up and return records relative to their contexts.</p>"},{"location":"linkcache/#mutability","title":"Mutability","text":""},{"location":"linkcache/#immutable-link-caches","title":"Immutable Link Caches","text":"<p>A LinkCache will look up records from a given context.  Being that this is a costly operation, it is preferable to cache information so that future lookups can happen faster.  However, one of the requirements for this optimization is that the presence of records in mods cannot be modified, or the link cache will potentially return faulty information.  </p> <p>Important Note:  When using Immutable Link Caches, it is safe to modify content ON records (Name of an Npc, Items in a Container, etc).  It is NOT safe to add new records to a Mod, or remove from a Mod.</p> <p>If you do not plan to add/remove records from the Mods, it is always recommended to use Immutable Link Caches, as they will be much more optimized.</p>"},{"location":"linkcache/#mutable-link-caches","title":"Mutable Link Caches","text":"<p>Sometimes it is desirable to have a mod on a Link Cache that you are allowed to modify.  Synthesis, for example, needs to be able to modify the outgoing Patch Mod object.</p> <p>In these scenarios, we can create a Mutable Link Cache.  This is a combination of an Immutable Link Cache for most of the mods in a load order, PLUS a mutable component for the final mods at the end that we want to modify.  As such there are a few things to consider: - Most of the load order still gets the speed optimizations of being immutable - We only pay the speed price when dealing with the one (few) mutable mods at the end. - Because of this structure, the mutable mods MUST be at the end.</p> <pre><code>// Immutable, readonly load order\nILoadOrderGetter&lt;ISkyrimModGetter&gt; readOnlyLoadOrder = ...;\n\n// A mutable mod we want to be able to change\nSkyrimMod mod = new SkyrimMod(ModKey.FromFileName(\"MyMod.esp\"), SkyrimRelease.SkyrimSE);\n\nvar linkCache = readOnlyLoadOrder.ToMutableLinkCache(mutableMods: mod);\n\n// No problems here\nvar npc = mod.Npcs.AddNew();\n</code></pre> <p>The result will be a mostly immutable Link Cache, with a mutable component at the end for <code>mod</code>.  It it safe to add/remove records from <code>mod</code>, as the Link Cache will react and continue to return accurate results even after the changes.</p>"},{"location":"linkcache/#memory-usage","title":"Memory Usage","text":"<p>When using Immutable Link Caches, references to records will be kept inside the cache.  This can lead to memory growth as records are queried.</p> <p>Mutable components of Link Caches do not cache records, and so will not use memory (beyond the memory used by the mutable mod itself).</p> <p>Since the LinkCache is just an object caching records relative to a context, you can easily release this memory by tossing your LinkCache away for the Garbage Collector to pick up once you're done with it, or want to make a new fresh cache.  (Perhaps a Clear() call will be added in the future, too)</p>"},{"location":"linkcache/#identifier-only-caches","title":"Identifier Only Caches","text":"<p>In some situations like the FormKey Picker, we only care about the FormKey and EditorID of records.  Caching the entire record is a waste of memory.</p> <pre><code>var linkCache = myLoadOrder.ToImmutableLinkCache(LinkCachePreferences.OnlyIdentifiers());\n</code></pre> <p>In this mode, the Link Cache will only store the FormKey/EditorID.  As such, any call that attempts to retrieve a record will throw an exception. Only certain calls that don't retrieve a whole record will be safe to use, namely <code>TryResolveIdentifier</code> or <code>AllIdentifiers</code>.</p>"},{"location":"linkcache/ModContexts/","title":"Mod Contexts","text":"<p>Mod Contexts are an opt-in advanced feature of most LinkCache functionality.  They act as storage for contextual information and the wiring and logic needed to perform certain actions in a context aware manner.</p> <p><code>ModContext</code>s contain: - <code>Record</code> - The record itself - <code>ModKey</code> - The <code>ModKey</code> that the associated record came from.  Not where it was originally defined and declared, but rather what mod contained the version of the record as it is. (usually the winning override mod) - <code>Parent</code> - If dealing with a \"nested\" record like <code>PlacedObject</code>, this will contain a reference to the parent record (like a <code>Cell</code>).</p> <p>ModContexts offer additional information as described above, but they also come with many useful features, which will be described in more detail below.</p>"},{"location":"linkcache/ModContexts/#retrieving-a-modcontext","title":"Retrieving a ModContext","text":""},{"location":"linkcache/ModContexts/#by-looping-winningoverrides","title":"By Looping WinningOverrides","text":""},{"location":"linkcache/ModContexts/#by-linkcache-lookups","title":"By LinkCache Lookups","text":"<p>A more typical Record Lookup call returns the record object directly: <pre><code>IFormLinkGetter&lt;INpcGetter&gt; myFormLink = ...;\n\nif (myFormLink.TryResolve(myLinkCache, out var record))\n{\nConsole.WriteLine($\"Found npc {record.FormKey} {record.EditorID}, but I don't know what mod contained it\");\n}\n</code></pre></p> <p>This API cannot inform you about what mod contained the record returned.  It just gives you the winning override record, if found.</p> <p>You can do a slightly different call to instead get a ModContext object, which contains the record object, but also a lot more information: <pre><code>IFormLinkGetter&lt;INpcGetter&gt; myFormLink = ...;\n\nif (myFormLink.TryResolveContext&lt;ISkyrimMod, ISkyrimModGetter, INpc, INpcGetter&gt;(myLinkCache, out var context))\n{\nConsole.WriteLine($\"Found npc {context.Record.FormKey} {record.Record.EditorID}, which was found in mod {context.ModKey}\");\n}\n</code></pre></p> <p>Note:  The API call is much more verbose.  More on that here.</p>"},{"location":"linkcache/ModContexts/#parent-concepts","title":"Parent Concepts","text":""},{"location":"linkcache/ModContexts/#deep-record-insertion-and-duplication","title":"Deep Record Insertion and Duplication","text":""},{"location":"linkcache/ModContexts/#complex-call-signature","title":"Complex Call Signature","text":""},{"location":"linkcache/Previous-Override-Iteration/","title":"Previous Override Iteration","text":"<p>A lot of functionality like Record Lookup or Winning Overrides deals with the \"winning\" version of a record, as in the record as it exists in the last Mod to override it on the Load Order.</p> <p>LinkCache offers an easy way to dig deeper into the load order and access the non-winning versions of records from previous mods.</p>"},{"location":"linkcache/Previous-Override-Iteration/#resolveall","title":"ResolveAll","text":"<p>While you can call it on a LinkCache directly, typically the preferred way to tap into this functionality is off a FormLink: <pre><code>IFormLinkGetter&lt;INpcGetter&gt; npcLink = ...;\n\n// Will loop over every version of that Npc\n// starting from the winning override, and ending with its originating definition\nforeach (INpcGetter npcRecord in npcLink.ResolveAll(myLinkCache))\n{\nConsole.WriteLine($\"The Npc's EditorID is {npcRecord.EditorID}\");\n}\n</code></pre></p> <p>With this pattern, you can loop over and interact with every override a record has from within a load order.</p>"},{"location":"linkcache/Previous-Override-Iteration/#resolveallcontexts","title":"ResolveAllContexts","text":"<p>If you look at the above code snippet, it's not as useful as it could be.  It will print all the EditorIDs, but if anything interesting happened you would not be able to tell what mod was responsible.</p> <p>This is because <code>ResolveAll</code> enumerates over records directly, and records do not have knowledge of what mod contained them.  They know what mod defined the record in the first place (as that's part of its FormKey), but that might not be the mod that originated the record's state being interacted with.</p> <p><code>ResolveAllContexts</code> is an alternative that returns ModContext objects instead, which have a lot more information/tooling about where a record came from.</p> <pre><code>IFormLinkGetter&lt;INpcGetter&gt; npcLink = ...;\n\nforeach (var npcRecordContext in npcLink.ResolveAllContexts&lt;ISkyrimMod, ISkyrimModGetter, INpc, INpcGetter&gt;(myLinkCache))\n{\nConsole.WriteLine($\"The Npc's EditorID is {npcRecordContext.Record.EditorID} in mod {npcRecordContext.ModKey}\");\n}\n</code></pre> <p>This will now print more interesting information, as we can now tell what mod made what change.</p> <p>However, you will notice that the call is much more complex, and requires you specify a lot more details.  You can read about why here.</p>"},{"location":"linkcache/Previous-Override-Iteration/#lazy-enumeration","title":"Lazy Enumeration","text":"<p>This is discussed in more detail here, but it is important to only loop over what you need.  This allows the Link Cache to only parse as deep into the Load Order as it needs.</p> <pre><code>// Break out of your loops if you're done\nforeach (var npcRecord in npcLink.ResolveAll(myLinkCache))\n{\nif (HasWhatINeed(npcRecord))\n{\n// Stop looping\nbreak;\n}\n}\n\n// Or only take what you're interested in\nINpcGetter[] recordWithPreviousOverride = npcLink.ResolveAll(myLinkCache)\n// This limits the looping to two levels deep, at most\n.Take(2)\n// Solidifies the results into an array for reuse\n.ToArray();\n\n// Got the winning record\nvar winningRecord = recordWithPreviousOverride[0];\nif (recordWithPreviousOverride.Length &gt; 1)\n{\n// And it has a previous override, too\nvar previousOverride = recordWithPreviousOverride[1];\n}\n</code></pre>"},{"location":"linkcache/Record-Lookup/","title":"Record Lookup","text":""},{"location":"linkcache/Record-Lookup/#tryresolve","title":"TryResolve","text":"<p><code>TryResolve</code> is the typical call for looking up records pointed to by a FormKey.  Similar to how Control-Clicking a FormID in xEdit will bring you to the record a FormID points to.  It takes a LinkCache as a parameter to the call, which will inspect the content it is attached to (whether it's a load order or a single mod) and try to locate the record that matches: - The FormKey (FormID) - The type specified</p> <p>If found, the record returned will be from the mod latest in the load order which is the \"winning\" override.</p> <p>For Immutable caches, the results will be cached, and subsequent lookups will be almost instant.</p>"},{"location":"linkcache/Record-Lookup/#formlink-entry-point","title":"FormLink Entry Point","text":"<p>While the LinkCache is the object doing the work, lookups are typically initiated from FormLink objects.  This is because they contain the typing information (Npc/Weapon/etc) already, so the call can be quite succinct: <pre><code>ILinkCache myLinkCache = ...;\nIFormLinkGetter&lt;INpcGetter&gt; myLink = ...;\n\nif (myLink.TryResolve(myLinkCache, out var npc))\n{\nConsole.WriteLine($\"Found the npc! {npc.EditorID}\");\n}\n</code></pre></p>"},{"location":"linkcache/Record-Lookup/#linkcache-entry-point","title":"LinkCache Entry Point","text":"<p>You can also initiate off of a LinkCache directly <pre><code>FormKey myFormKey = ...;\n\nif (myLinkCache.TryResolve(myFormKey, out var record))\n{\nConsole.WriteLine($\"Found a record! {record.EditorID}\");\n}\n</code></pre></p> <p>But the code above has two problems: - It will only be able to return <code>IMajorRecordGetter</code> or some other very umbrella type - It will complain that an unoptimized call is used</p> <p>This is because the above call has no information about the record type being looked up.  To help provide this information, you can instead: <pre><code>FormKey myFormKey = ...;\n\nif (myLinkCache.TryResolve&lt;INpcGetter&gt;(myFormKey, out var npc))\n{\nConsole.WriteLine($\"Found an npc! {npc.EditorID}\");\n}\n</code></pre></p> <p>Now that the type is specified, it will run faster and be able to return a more appropriate type (INpcGetter) for you to use.</p>"},{"location":"loadorder/","title":"Load Order","text":"<p>A Load Order represents a set of mods in a given order, where the mods loaded later \"win\" and override the records from previous mods.</p>"},{"location":"loadorder/#getting-a-load-order","title":"Getting a Load Order","text":"<p>Typically you will not construct a Load Order object yourself.  Most times, using a Game Environment is more desirable, and will have a Load Order for you to use.</p> <p>If you want to construct a Load Order object more manually, this will be discussed later in the article.</p>"},{"location":"loadorder/#modlistings","title":"ModListings","text":"<p>A <code>ModListing</code> consists of: - A <code>ModKey</code> - Whether it's marked as enabled - Whether \"ghosted\" and has an extra suffix causes the game to ignore it</p> <p>A <code>ModListing</code> can also be generic, such as <code>ModListing&lt;ISkyrimModGetter&gt;</code>.  This will then also contain: - A nullable Mod object, which is present if the Mod in question exists on disk in the Data Folder</p>"},{"location":"loadorder/#interacting-with-loadorder","title":"Interacting with LoadOrder","text":"<p><code>LoadOrder</code> as a container has a lot of accessors like <code>TryGetValue(ModKey, out T item)</code> or <code>IndexOf(ModKey)</code> that make it act simultaneously like a dictionary and a list.</p>"},{"location":"loadorder/#priority-vs-listed-ordering","title":"Priority vs Listed Ordering","text":"<p>While <code>LoadOrder</code> is a \"list\" of <code>ModListing</code> object, two properties are exposed for when you want to enumerate to help clarify behavior: - ListedOrder - Enumerates items in the order they were listed - PriorityOrder - Enumerates the items so that highest priority comes first (reverse)</p> <p>Enumeration is exposed like this just for the extra clarification and to reduce confusion of what ordering things are being iterated.  This is very clearly iterating the highest priority mods first, and will probably have <code>Skyrim.esm</code> or whatever base game file last: <pre><code>foreach (var mod in loadOrder.PriorityOrder)\n{\n// ...\n}\n</code></pre></p>"},{"location":"loadorder/#filtering-listings","title":"Filtering Listings","text":""},{"location":"loadorder/#accessing-specific-listings","title":"Accessing Specific Listings","text":"<p><code>LoadOrder</code> has a lot accessors for checking if certain mods are on the list, and retrieving them. <pre><code>var modKey = ModKey.FromFilePath(\"Skyrim.esm\");\nLoadOrder loadOrder = ...;\n\nif (loadOrder.TryGetValue(modKey, out var listing)\n{\n// Load order had that mod\n}\n\n// Also has typical contains and index access\nif (loadOrder.ContainsKey(modKey))\n{\nlisting = loadOrder[modKey];\n}\n\n// There is also int index API\nint index = loadOrder.IndexOf(modKey);\nif (loadOrder.TryGetIndex(index, out listing)\n{\n// Got the listing by index\n}\n\n// And Clear/Add\nloadOrder.Clear();\nloadOrder.Add(listing);\n</code></pre></p>"},{"location":"loadorder/#reading-a-load-order","title":"Reading a Load Order","text":""},{"location":"loadorder/#getting-listings","title":"Getting Listings","text":"<p>If you want to load the typical load order that the game itself will use: <pre><code>IEnumerable&lt;IModListingGetter&gt; loadOrder = LoadOrder.GetListings(GameRelease.SkyrimSE, pathToDataFolder);\n</code></pre></p> <p>This gives a simple enumerable of the <code>ModListing</code> in the order they will be loaded.</p>"},{"location":"loadorder/#importing-mods","title":"Importing Mods","text":"<p>Usually you want more than just the list of <code>ModListings</code> in order; You want the associated mods as accessible objects to use.</p> <p><code>LoadOrder</code> is just a normal object that you could declare and fill yourself, but there are a few convenience methods to do this for you:</p> <pre><code>LoadOrder&lt;IModListing&lt;ISkyrimModGetter&gt;&gt; loadOrder = LoadOrder.Import&lt;ISkyrimModGetter&gt;(\ndataFolder: pathToDataFolder,\nloadOrder: LoadOrder.GetListings(GameRelease.SkyrimSE, pathToDataFolder),\ngameRelease: GameRelease.SkyrimSE);\n</code></pre>"},{"location":"loadorder/#specifying-getter-vs-setter","title":"Specifying Getter vs Setter","text":"<p>The choice of specifying Getter or Setter interfaces (<code>ISkyrimMod</code> vs <code>ISkyrimModGetter</code>) is important, as that will drive the style that the mods are imported with.  If the Getter is specified, then the more optimized Binary Overlay systems will be used.  If Setter is specified, then all the import work will need to be done up front into a mutable object.</p>"},{"location":"loadorder/#writing-a-load-order","title":"Writing a Load Order","text":"<p>A <code>LoadOrder</code> can also export its contents to a file. <pre><code>IEnumerable&lt;ModListing&gt; myListings = ...;\nLoadOrder.Write(\nsomePath, GameRelease.SkyrimSE,\nmyListings);\n</code></pre></p>"},{"location":"loadorder/#pluginlistings-and-creationclublistings","title":"PluginListings and CreationClubListings","text":"<p>The above API abstracts away the complications that a Load Order is driven from a few sources: - Implicit Listings (Mods that don't need to be listed, but are assumed) - Normal Plugins File (Plugins.txt) - Installed Creation Club Mods ([GameName].ccc)</p> <p>Logic related to each concept lives in its own class: - Implicits.Listings - PluginListings - CreationClubListings</p> <p>In each you will be able to do tasks related to that specific load order source concept.</p>"},{"location":"loadorder/Winning-Overrides/","title":"Winning Override Iteration","text":""},{"location":"loadorder/Winning-Overrides/#winning-overrides","title":"Winning Overrides","text":"<p>It is very common task to retrieve the \"winning override\" version of each record.  These are the versions of each record as they exist in the mod with the highest priority, and will thus be what's used by the game when running.</p> <p>There are extension methods to streamline this: <pre><code>LoadOrder&lt;ModListing&lt;ISkyrimModGetter&gt;&gt; loadOrder = ...;\nforeach (var npc in loadOrder.PriorityOrder.Npc().WinningOverrides())\n{\n// Code to process the winning override version each NPC that appears on the loadorder\nConsole.WriteLine($\"Processed {npc.EditorID}\");\n}\n</code></pre></p> <p>If you then want to take winning overrides and add them to your mod with some modifications, this topic is covered more in depth here.</p>"},{"location":"loadorder/Winning-Overrides/#winning-context-overrides","title":"Winning Context Overrides","text":"<p>The above loop will just give you each record in the game with it's \"winning\" content.  Sometimes more information is needed, though.</p> <p>You can instead opt to iterate over ModContexts which is a wrapper object containing the record of interest PLUS other useful information and features.</p> <pre><code>LoadOrder&lt;ModListing&lt;ISkyrimModGetter&gt;&gt; loadOrder = ...;\nforeach (var npcContext in loadOrder.PriorityOrder.Npc().WinningContextOverrides())\n{\n// Code to process the winning override version each NPC that appears on the loadorder\nConsole.WriteLine($\"Processed {npcContext.Record.EditorID} as defined in mod {npcContext.ModKey}\");\n}\n</code></pre> <p>You can read more about ModContexts to see all the features they offer.</p>"},{"location":"lowlevel/","title":"Low Level Tools","text":"<p>The API and tools listed in the Plugin Record Suite are intended to expose Bethesda records in an organized, strongly typed, and (hopefully) less error prone fashion.  However, some tasks and some users require a less safe and more direct approach to get the job done.</p> <p>This section is about some of the mechanics and tools under the hood, and are recommended for more advanced users.</p>"},{"location":"lowlevel/#reasoning-and-typical-applications-of-low-level-tooling","title":"Reasoning and Typical Applications of Low Level Tooling","text":""},{"location":"lowlevel/#cross-game-processing","title":"Cross-game Processing","text":"<p>The Plugin Record Suite objects fall short when the task you are trying to accomplish is to be applied to multiple Bethesda games.  There are no halfway hybrid generated classes that can parse and contain both Skyrim and Oblivion NPCs, for example.</p> <p>Interfaces can provide a small bit of relief, allowing some fields that are common to many records to be exposed.  <code>INamed</code> is an example of this.  Both Skyrim and Oblivion NPCs implement it, and so code that processed an <code>IEnumerable&lt;INamed&gt;</code> could handle both.</p> <p>Low Level Tooling can be used instead of the generated records to write logic that can apply to multiple games where interfaces aren't good enough.  It comes at the cost of being a lot more error prone to use, losing a lot of the common functionality (Equals/ToString/etc), and requiring a lot more knowledge of binary details.</p>"},{"location":"lowlevel/#testing-the-record-suite-itself","title":"Testing the Record Suite Itself","text":"<p>The generated records do the bulk of the parsing and data handling, but they cannot test themselves for correctness.  The manual granularity of the Low Level Tools allow for code and logic to be written for testing projects to do the work needed to confirm correctness of the generated records.</p>"},{"location":"lowlevel/Binary-Streams/","title":"Binary Streams","text":""},{"location":"lowlevel/Binary-Streams/#binaryreadstream","title":"BinaryReadStream","text":"<p><code>IBinaryReadStream</code> is an interface that exposes binary extraction from a stream, with <code>BinaryReadStream</code> being a basic implementation.  The interface offers calls to read <code>int</code>, <code>short</code>, <code>uint</code>, <code>double</code>, <code>byte[]</code>, and even newer concepts such as <code>ReadOnlySpan&lt;byte&gt;</code> and <code>ReadOnlyMemorySlice&lt;byte&gt;</code>.</p>"},{"location":"lowlevel/Binary-Streams/#mutagenbinaryreadstream","title":"MutagenBinaryReadStream","text":"<p>This is just a further extension on BinaryReadStream, offering additionally: - A Header Struct object for reference when alignment is important - An offset member, to help calculate position relative to a source file, if the MutagenBinaryReadStream happens to be a substream on only a slice of data.</p>"},{"location":"lowlevel/Binary-Utility/","title":"Binary Utility","text":""},{"location":"lowlevel/Binary-Utility/#binarystringutility","title":"BinaryStringUtility","text":"<p>Bethesda games store their strings on disk in a single byte format, with a null terminator.  There are some convenience parsing functions inside <code>BinaryStringUtility</code> to convert these to C# strings.</p>"},{"location":"lowlevel/Binary-Utility/#tozstring","title":"ToZString","text":"<p>This function assumes the entire input span is bytes that need to be converted to a string.  There should be no null termination at the end, or it will be included in the resulting string.</p>"},{"location":"lowlevel/Binary-Utility/#processwholetozstring","title":"ProcessWholeToZString","text":"<p>This function assumes the entire input span is part of the string, and may have a null termination.  It will trim off the null termination if it exists, and return a string.  Good for typical use. <pre><code>var subRecordBytes = ...;\nvar subRecordFrame = meta.SubRecordFrame(someBytes.AsSpan());\nstring str = BinaryStringUtility.ProcessWholeToZString(subRecordFrame.Content);\n</code></pre></p>"},{"location":"lowlevel/Binary-Utility/#parseunknownlengthstring","title":"ParseUnknownLengthString","text":"<p>Sometimes you might not be able to trim your input span to a string's contents exactly.  This call will help by locating the first null byte, and retrieving the string up until that point. <pre><code>var bytesOfUnknownLength = ...;\nstring str = BinaryStringUtility.ParseUnknownLengthString(bytesOfUnknownLength.AsSpan());\nvar amountParsed = str.Length + 1; // +1 for the null termination that was trimmed\n</code></pre></p>"},{"location":"lowlevel/Binary-Utility/#subrecord-iteration-and-location","title":"SubRecord Iteration and Location","text":"<p>There are some convenience methods for iterating and locating Subrecords in a set of raw bytes in <code>UtilityTranslation</code>.  These are extension methods onto <code>HeaderConstants</code> and <code>MajorRecordFrame</code>, so they can be used directly from those objects.</p>"},{"location":"lowlevel/Binary-Utility/#enumeratesubrecords","title":"EnumerateSubrecords","text":"<p>Print some metadata for all Subrecords in a MajorRecord <pre><code>var meta = HeaderConstants.Skyrim;\nbyte[] majorRecordBytes = ...;\nvar majorFrame = meta.MajorRecordFrame(majorRecordBytes.AsSpan());\n\nforeach (KeyValuePair&lt;RecordType, int&gt; loc in majorFrame.EnumerateSubrecords())\n{\n// Scope to the start of the subrecord's data, relative to the MajorRecord content\nvar subRecordSpan = majorFrame.Content.Slice(loc.Value);\nvar subHeader = meta.SubRecord(subRecordSpan);\nSystem.Console.WriteLine($\"Found subrecord {loc.Key} at position {loc.Value}, with length {subHeader.ContentLength}\");\n}\n</code></pre></p>"},{"location":"lowlevel/Binary-Utility/#tryfindfirstsubrecord","title":"TryFindFirstSubrecord","text":"<p>This call returns the first location of a subrecord type.  Good for locating a specific subrecord <pre><code>if (majorFrame.TryFindFirstSubrecord(\"EDID\", out SubRecordFrame subFrame))\n{\nSystem.Console.WriteLine($\"Found EDID with length {subFrame.Header.ContentLength}: \");\nSystem.Console.WriteLine($\"   {BinaryStringUtility.ProcessWholeToZString(subFrame.Content)}\");\n}\n</code></pre></p>"},{"location":"lowlevel/Binary-Utility/#findfirstsubrecords","title":"FindFirstSubrecords","text":"<p>This call returns the first location of each subrecord type queried for.  Good for finding a set of subrecords in one pass. <pre><code>var finds = majorFrame.FindFirstSubrecords(\"EDID\", \"FULL\");\n// If EDID found\nif (finds[0] != -1)\n{\n// Scope to the start of the subrecord's data, relative to the MajorRecord content\nvar subRecordSpan = majorFrame.Content.Slice(finds[0]);\nvar subFrame = meta.SubRecord(subRecordSpan);\nSystem.Console.WriteLine($\"Found EDID with length {subFrame.Header.ContentLength}: \");\nSystem.Console.WriteLine($\"   {BinaryStringUtility.ProcessWholeToZString(subFrame.Content)}\");\n}\n\n// If FULL found\nif (finds[1] != -1)\n{\n// Scope to the start of the subrecord's data, relative to the MajorRecord content\nvar subRecordSpan = majorFrame.Content.Slice(finds[1]);\nvar subFrame = meta.SubRecord(subRecordSpan);\nSystem.Console.WriteLine($\"Found FULL with length {subFrame.Header.ContentLength}: \");\nSystem.Console.WriteLine($\"   {BinaryStringUtility.ProcessWholeToZString(subFrame.Content)}\");\n}\n</code></pre></p>"},{"location":"lowlevel/Binary-Utility/#compilefirstsubrecordlocations","title":"CompileFirstSubrecordLocations","text":"<p>Similar to FindFirstSubrecords, except the results are put into a <code>Dictionary&lt;RecordType, int&gt;</code> for cleaner use.  Comes at the cost of higher overhead to construct this dictionary.  Another low cost alternative is just using <code>EnumerateSubrecords</code> with a <code>switch</code> statement.</p> <pre><code>var edid = new RecordType(\"EDID\");\nvar full = new RecordType(\"FULL\");\nvar finds = majorFrame.CompileFirstSubrecordLocations(edid, full);\n\n// If EDID found\nif (finds.TryGetValue(edid, out var loc))\n{\n// Scope to the start of the subrecord's data, relative to the MajorRecord content\nvar subRecordSpan = majorFrame.Content.Slice(loc);\nvar subFrame = meta.SubRecord(subRecordSpan);\nSystem.Console.WriteLine($\"Found EDID with length {subFrame.Header.ContentLength}: \");\nSystem.Console.WriteLine($\"   {BinaryStringUtility.ProcessWholeToZString(subFrame.Content)}\");\n}\n\n// If FULL found\nif (finds.TryGetValue(full, out loc))\n{\n// Scope to the start of the subrecord's data, relative to the MajorRecord content\nvar subRecordSpan = majorFrame.Content.Slice(loc);\nvar subFrame = meta.SubRecord(subRecordSpan);\nSystem.Console.WriteLine($\"Found FULL with length {subFrame.Header.ContentLength}: \");\nSystem.Console.WriteLine($\"   {BinaryStringUtility.ProcessWholeToZString(subFrame.Content)}\");\n}\n</code></pre>"},{"location":"lowlevel/Binary-Utility/#recordlocator","title":"RecordLocator","text":"<p><code>RecordLocator</code> is a convenience class that processes a mod stream and returns all the locations of Groups and MajorRecords.</p> <p>It takes a few optional arguments: - RecordInterest, to limit the search to specific <code>RecordType</code>s - Additional Criteria lambda, to add custom filter logic</p> <pre><code>using var stream = new MutagenReadStream(pathToMod, HeaderConstants.Skyrim);\nRecordLocator.FileLocations locs = RecordLocator.FileLocations.GetFileLocations(\nstream,\n// Only search for NPCs\nnew RecordInterest(\"NPC_\"),\n// That are compressed\nadditionalCriteria: (stream, recordType, recLength) =&gt;\n{\nvar majorHeader = stream.Meta.GetMajorRecord(stream);\nreturn majorHeader.IsCompressed;\n});\n\n/// Can enumerate Group locations\nforeach (var groupLoc in locs.GrupLocations)\n{\nSystem.Console.WriteLine($\"Group located at: {groupLoc}\");\n}\n\n/// Can enumerate MajorRecord locations\nforeach (KeyValuePair&lt;long, (FormID FormID, RecordType Record)&gt; recLoc in locs.ListedRecords)\n{\nSystem.Console.WriteLine($\"MajorRecord located at: {recLoc.Key}, {recLoc.Value.FormID}\");\n}\n\n/// Can query a specific FormID's location\nif (locs.TryGetSection(someFormID, out RangeInt64 loc))\n{\nstream.Position = loc.Min;\nvar header = stream.Meta.ReadMajorRecord(stream);\nSystem.Console.WriteLine($\"MajorRecord type: {header.RecordType}\");\n}\n\n/// Can query what record exists at a location\nif (locs.TryGetRecord(loc: 0x1234, out (FormID FormID, RecordType Record) rec))\n{\nSystem.Console.WriteLine($\"{rec.Record}: {rec.FormID}\");\n}\n\n/// Can enumerate the parent Group locations for a FormID\nforeach (var groupLoc in locs.GetContainingGroupLocations(someFormID))\n{\nstream.Position = groupLoc;\nvar groupHeader = stream.Meta.ReadGroupHeader(stream);\nSystem.Console.WriteLine($\"{someFormID} has parent group at: {groupLoc}.  Type: {groupHeader.GroupType}\");\n}\n</code></pre> <p>This class just provides a common use case of locating records.  If more fine tuned logic is needed, just fall back to using Header Struct parsing yourself with the extra logic you need.</p> <p>Note that this class uses FormID, and does not make use of the abstraction concepts found in ModKey, FormKey, FormLink</p>"},{"location":"lowlevel/Binary-Utility/#decompression","title":"Decompression","text":"<p>MajorRecords with their compression flag enabled come in a compressed format.  The byte content needs to be unzipped before it can be read.</p>"},{"location":"lowlevel/C%23-Span/","title":"C# Span","text":"<p><code>Span</code>s are not a Mutagen concept, but rather a general C# concept.  However, since they are used extensively by Mutagen's parsing systems and they are a newer concept just recently added to C#, it will be covered to some extent here.</p> <p>If you are more interested in Mutagen-specific concepts, you can skip this section.</p>"},{"location":"lowlevel/C%23-Span/#spans-are-sub-sections-of-arrays","title":"Spans are Sub-Sections of Arrays","text":"<p>A <code>Span&lt;T&gt;</code> is very similar to a <code>T[]</code>.  It points to a spot in memory where T objects reside, like an array.  Consider using a typical array, however, where you wanted some logic to process just a subsection of it.  You would either have to: 1) Pass the array to a function, with <code>start</code> and <code>end</code> indices of where you wanted to process. 2) Make a new smaller array, and copy the data over, using that array with just the interesting data to represent a \"subsection\" of the original array.</p> <p><code>Span&lt;T&gt;</code> would be an alternate way of handling the above problem.  It lets you \"scope\" to a small subsection of an array, without actually creating a new array. <pre><code>byte[] originalArray = new byte[150];\n\n// This scopes to only \"contain\" 5 bytes, framing indices 10-14 of the original array\nSpan&lt;byte&gt; subSection = originalArray.AsSpan(10, 5);\n\n// This scopes in even farther, pointing to indices 2-3 of subSection,\n// which are also the indices 12-13 of the original array.\nSpan&lt;byte&gt; evenSmallerSection = subSection.Slice(2, 2);\n\n// Modify a byte in the smaller sub section, affecting the single common array at index 13\nevenSmallerSection[1] = 123;\n</code></pre></p> <p>Changing the value in <code>evenSmallerSection</code> will affect all others; They point to the same underlying array and space in memory.</p>"},{"location":"lowlevel/C%23-Span/#faster-substring-alternative","title":"Faster Substring Alternative","text":"<p>Trimming off or grabbing a few characters on a <code>string</code> using Substring() means allocating a whole 2nd string with mostly the same data, just some characters trimmed off.  This is a fairly wasteful operation.</p> <p><code>Span</code> concepts are great for Substring logic, as the original <code>string</code> memory can be reused while Span just points to small substrings of the original string without copies or new allocations. <pre><code>string str = \"Junk Good Stuff Junk\";\nSpan&lt;char&gt; origSpan = str.AsSpan();\n\n// Equivalent to .Substring(5) to get rid of first Junk\nSpan&lt;char&gt; result = origSpan.Slice(4);\n\n// Get rid of second junk by using TrimEnd of string \"Junk\"\nresult = result.TrimEnd(\"Junk\".AsSpan());\n\n// Trim whitespace\nresult = result.Trim();\n\n// Print \"Good Stuff\"\nSystem.Console.WriteLine(result.ToString());\n\n// Note that the above call still has to call ToString(), which does allocate a new string with \"Good Stuff\".\n// But at least we avoided several new transition strings while we were processing to our end result.\n\n// Additionally, the WriteLine() API might be upgraded in C# to eventually take ReadOnlySpan&lt;char&gt; as input, too\n</code></pre>"},{"location":"lowlevel/C%23-Span/#interpreting-data-as-another-type","title":"Interpreting Data as Another Type","text":"<p>Another cool trick <code>Span</code>s can do is overlay on top of a <code>byte[]</code> a <code>Span</code> of a different type: <pre><code>byte[] someBytes = new byte[16];\n// Fill with some data\n\n// \"Overlay\" a uint Span on our bytes\nSpan&lt;uint&gt; uintSpan = someBytes.AsUInt32Span();\n\n// Retrieve the uint contained in bytes 4-7\nuint secondNumber = uintSpan[1];\n\n// Will loop 4 times\nfor (int i = 0 ; i &lt; uintSpan.Length ; i++) {\n// Print all 4 uints\nSystem.Console.WriteLine(uintSpan[i]);\n\n// Can also set original data.  Setting bytes to FFFF\nuintSpan[i] = uint.MaxValue;\n}\n\n// All bytes in someBytes now contain 255 / 0xFF\n</code></pre></p>"},{"location":"lowlevel/C%23-Span/#parsing-data-from-span","title":"Parsing Data from Span","text":"<p>Numeric primitives can be extracted from a <code>Span&lt;byte&gt;</code> fairly easily: <pre><code>Span&lt;byte&gt; span = ...;\n\n// Read int from span's bytes starting at index 0\nint i = BinaryPrimitives.ReadInt32LittleEndian(span);\n\n// Read short from span's bytes starting at index 7 (going to index 8)\nshort s = BinaryPrimitives.ReadInt16LittleEndian(span.Slice(7));\n</code></pre></p> <p>Strings (at least in the realm of Mutagen) are not as easily extracted, as <code>char</code> is 2 bytes in C#, while Bethesda binary has 1 byte chars and have null termination concepts.  There are utility functions provided by Mutagen for this, though. <pre><code>Span&lt;byte&gt; span = ...;\n\n// Find next null termination, convert bytes to standard C# string\nstring str = BinaryStringUtility.ProcessWholeToZString(span);\n\n// Assumes entire span is relevant string information, and will turn\n// all contained bytes into a resulting string\nstr = BinaryStringUtility.ToZString(span.Slice(11, 23));\n</code></pre></p>"},{"location":"lowlevel/C%23-Span/#memoryslice-alternative-for-non-stack-usage","title":"MemorySlice Alternative for Non-Stack Usage","text":"<p>One of the major downsides of <code>Span</code> is that it is a <code>ref struct</code> which can only \"live\" on the stack.  This means it cannot be a member of a class, or even be associated with async/await concepts, among other things.</p> <p>In this case, <code>MemorySlice</code> is an alternative concept (subsection of an array) that can live outside of the stack.</p>"},{"location":"lowlevel/Game-Constants/","title":"Game Constants","text":"<p>As Bethesda games are released, headers are modified slightly.  They still have a lot in common, but certain things move or the total length changes, or something else that will misalign any common parsing code.</p> <p><code>GameConstants</code> is a class containing all the various alignment information specific to a game.  Things like: - ModHeaderLength - HeaderIncludedInLength - LengthLength (amount of bytes the 'length' section is) - Etc</p> <p><code>GameConstants</code> also has static instances of itself for each Bethesda game, so that users can look up the specific header details for a specific game.  There is also a <code>GameCategory</code> enum that can be used to query to get the constants: <pre><code>var oblivionHeaderData = GameConstants.Oblivion;\n// An alternate way\noblivionHeaderData = GameConstants.Get(GameCategory.Oblivion);\nvar headerLength = oblivionHeaderData.MajorConstants.HeaderLength;\n</code></pre></p> <p>The usefulness of this \"registry\" is that code can be written once, while referring to a header meta object to account for differences in the games.  Give the code a different meta object to refer to for the appropriate game, and all the alignment works out.</p>"},{"location":"lowlevel/Header-Structs/","title":"Header Structs","text":""},{"location":"lowlevel/Header-Structs/#general-concept","title":"General Concept","text":"<p>Header Structs are lightweight overlays that \"lay\" on top of some bytes and offers API to retrieve the various header fields or content bytes they contain.  They are extremely cheap to create, as they do no parsing unless asked.  They are aware of any differences in data alignments from game to game, so the same systems can be applied even if alignments change slightly.</p> <p>Using Header Structs, very performant and low level parsing is possible while retaining a large degree of safety and usability.  </p> <p>Some notable features: - Alignment is handled internally.  User can access the fields they are interested in, without needing to worry about proper offsetting. - No parsing is done except what the user asks for.  If only one field is accessed, then most of the header data will remain unparsed, and that work skipped. - Code written with this setup can work with any Bethesda game, as swapping out Game Constants will realign everything properly. - No data is copied, as the structs are simply overlaid on top of the original source bytes.</p> <p>They still require a lot of knowledge of the underlying binary structures of a mod, but the system goes a long way to empower the user to do it quickly, and with minimal potential for typo or misalignment errors.</p>"},{"location":"lowlevel/Header-Structs/#example-usage","title":"Example Usage","text":"<p>The following code will print all EditorIDs of all npcs from any game type. <pre><code>var modPath = ModPath.FromPath(\"SomeFolder/Skyrim.esm\");\nvar release = GameRelease.SkyrimSE;\nvar encoding = MutagenEncodingProvider.Instance.GetEncoding(release, Language.English);\n\nusing var stream = new MutagenBinaryReadStream(modPath, release);\n\n// Skip mod header\nstream.ReadModHeaderFrame();\n\n// Keep reading group frames out of the stream\nwhile (stream.TryReadGroupFrame(out var groupFrame))\n{\n// Check that the group contains NPCs\nif (groupFrame.ContainedRecordType != RecordTypes.NPC_) continue;\n\n// Loop over all major record structs in the group's content\nforeach (var majorPin in groupFrame)\n{\n// Iterate and search the subrecords for EDID\nif (majorPin.Frame.TryLocateSubrecordFrame(RecordTypes.EDID, out var subFrame))\n{\n// Interpret the subrecord's content as a string and print\nSystem.Console.WriteLine($\"{majorFrame.FormID} =&gt; {subFrame.AsString(encoding)}\");\n}\n}\n\n// We found a matching NPC group, we'll assume there's no others and break\nbreak;\n}\n</code></pre></p> <p>This code will only do the minimal parsing necessary to locate/print the EditorIDs.  Most data will be skipped over and left unparsed.</p>"},{"location":"lowlevel/Header-Structs/#headers-frames-and-pins","title":"Headers, Frames and Pins","text":"<p>Header Structs come in a few combinations and flavors.  The above code makes use of several of them.</p>"},{"location":"lowlevel/Header-Structs/#categories","title":"Categories","text":"<p>There are Header Structs for: - Groups - MajorRecords - Subrecords - ModHeader</p> <p>These are the few different types of records we can expect to encounter in a mod file, and there is a separate struct for each, offering the specific API for its type.</p>"},{"location":"lowlevel/Header-Structs/#flavors","title":"Flavors","text":"<p>Each category also comes in a few flavors.</p>"},{"location":"lowlevel/Header-Structs/#header","title":"Header","text":"<p>This is the most basic version that has been discussed in the descriptions above.  It overlays on top of bytes and offers API to access the various aspects of the header.</p> <p>Typical accessors include: - <code>RecordType</code> that the header is (EDID, NPC_, etc) - <code>HeaderLength</code> - <code>ContentLength</code> - <code>TotalLength</code> - Other fields more specialized for the category (<code>MajorRecordFlags</code>, <code>FormID</code>, etc)</p> <p>All of these fields align themselves properly by bouncing off a Game Constantsobject which has all the appropriate alignment information.</p>"},{"location":"lowlevel/Header-Structs/#frame","title":"Frame","text":"<p>Frames add a single additional member <code>ReadOnlyMemorySlice&lt;byte&gt; Content { get; }</code>, and thus overlay on top of a whole record in its entirety, both the header and its content.  This struct offers a nice easy package to access anything about an entire record in one location.</p>"},{"location":"lowlevel/Header-Structs/#pin","title":"Pin","text":"<p>Pins add yet another single additional member <code>int Location { get; }</code>.  This represents the location a frame exists relative to its parent.  This facilitates parsing and operations where knowing a record's location is important.</p>"},{"location":"lowlevel/Header-Structs/#additional-functionality","title":"Additional Functionality","text":""},{"location":"lowlevel/Header-Structs/#iteration","title":"Iteration","text":"<p>Both Group and MajorRecord Frames offer iteration functionality. <pre><code>foreach (var subrecordPin in majorRecordFrame)\n{\n   ...\n}\n</code></pre> This allows the user to easily iterate and process contained records without needing to manually construct and align the headers themselves.</p>"},{"location":"lowlevel/Header-Structs/#subrecord-location","title":"Subrecord Location","text":"<p>MajorRecord Frames also have API for searching for a specific subrecord type.</p> <pre><code>var edidType = new RecordType(\"EDID\");\nif (majorRecordFrame.TryLocateSubrecordFrame(edidType, out var edidFrame))\n{\n   ...\n}\n</code></pre> <p>This allows users to easily locate a specific record they are looking for, without needing to iterate and search themselves.</p> <p>Note that it does iterate each Subrecord internally, so it is not a good solution if you are trying to process/find a large portion of Subrecords within a single Major Record.  It is more appropriate for finding one or two specific ones.  If you want to process all subrecords by type, it is recommended you iterate and switch on the type directly, or store the resulting SubrecordPins in a dictionary for later use.</p>"},{"location":"lowlevel/Header-Structs/#subrecord-frame-data-interpretation","title":"Subrecord Frame Data Interpretation","text":""},{"location":"lowlevel/Header-Structs/#primitives","title":"Primitives","text":"<p>Once a Subrecord Frame is located that you wish to retrieve data from, the content is still only offered as raw bytes (or rather, <code>ReadOnlyMemorySlice&lt;byte&gt;</code>).  There are a lot of functions to help interpret that data to the appropriate type, while confirming correctness. <pre><code>var subrecordFrame = ...;\nint contentAsInt = subrecordFrame.AsInt32();\n</code></pre> This code will interpret the Subrecord Frame's content as an int for you.  It will also do the additional safety check to confirm that the Subrecord's content is exactly 4 bytes.  If the content length is 3, or 5, say, then the call will throw an exception alerting you to an unexpected length.</p> <p>If you happen to want to extract an integer without enforcing that the content is exactly 4 bytes, then accessing the byte slice directly is the route to take. <pre><code>var subrecordFrame = ...;\nint contentAsInt = subrecordFrame.Content.Int32();\n</code></pre> This route will not do the check to enforce that the content length is exactly 4.  It would only throw if the content wasn't long enough to be an int at all (less than 4).</p>"},{"location":"lowlevel/Header-Structs/#strings","title":"Strings","text":"<p>Strings, unlike primitives, do not have a set length.  So the call to interpret a Subrecord Frame's content as a string is just for convenience, and does not add any safety mechanisms. <pre><code>var subrecordFrame = ...;\nstring contentAsString = subrecordFrame.AsString();\n</code></pre></p>"},{"location":"lowlevel/Header-Structs/#writable-structs","title":"Writable Structs","text":"<p>All the above concepts mentioned have been read-only.  Header Structs can be overlaid on top of spans, and read data from them.</p> <p>There are writable structs as well, which have both getter and setter API.  You can then read a section of data, and then make modifications which will affect the source <code>byte[]</code> at the correct indices.</p> <p>These systems are less mature, but will be expanded on in the future.</p>"},{"location":"plugins/","title":"Index","text":""},{"location":"plugins/#plugin-record-suite","title":"Plugin Record Suite","text":"<p>Mutagen offers custom classes, interfaces, and functionality for each Bethesda record type.  For example, if you want to deal with and modify Potions in a mod you can read/write using a <code>Potion</code> class which has members for every stat and field.  It comes with a suite of functionality alongside, such as how to print to string, how to compare equality, how to write itself, etc.</p>"},{"location":"plugins/#code-is-generated","title":"Code is Generated","text":"<p>Records and their functionality are created and maintained via a code generation library.  As such, the records feel like they are hand written, without actually needing to write them by hand.  As new functionality is added or internal optimization is improved, most of Mutagen's code is regenerated to gain all the benefits without needing to manually update the definitions for every record that exists. </p>"},{"location":"plugins/#explore","title":"Explore","text":"<p>Most functionality and use case scenarios deal with these generated records in some way.  Learn more and explore the details in the other related pages.</p>"},{"location":"plugins/Abstract-Subclassing/","title":"Abstract Subclassing","text":""},{"location":"plugins/Abstract-Subclassing/#what-is-abstract-subclassing","title":"What is Abstract Subclassing","text":"<p>Occasionally records will have an Abstract subobject.   </p> <p>This article will go over the concepts of Abstract Subclassing through the lens of looking at a specific example found in Skyrim Npc.   Other records have similar but different concepts.  </p> <p>Consider Skyrim's NpcConfiguration records:</p> <pre><code>public interface INpcConfigurationGetter\n{\n// ...\nshort MagickaOffset { get; }\nshort StaminaOffset { get; }\n// The field below is an abstract subclass\nIANpcLevelGetter Level { get; }\n// ...\n}\n</code></pre>"},{"location":"plugins/Abstract-Subclassing/#why-is-it-needed","title":"Why is it Needed?","text":"<p>Why is the concept of <code>Level</code> a weird <code>ANpcLevel</code> object?  </p> <p>The subclassing helps encapsulate some complexity while remaining consistent and type safe.</p> <p>Consider that <code>NPC_</code>'s <code>Level</code> field is an integer normally.  But if you turn on the <code>PC Level Mult</code> flag, it suddenly acts as a float.   So how can Mutagen expose this in a type safe manner if the field can just change its type depending on a switch somewhere else?</p> <p>Mutagen exposes this by using subclassing.  <code>ANpcLevel</code> has two subclasses: - <code>NpcLevel</code>, with <code>Level</code> as an integer - <code>PcLevelMult</code>, with <code>Level</code> as a float</p>"},{"location":"plugins/Abstract-Subclassing/#setting-an-abstract-subclass-member","title":"Setting an Abstract Subclass Member","text":"<p>You will notice Mutagen does not expose the <code>Pc Level Mult</code> flag.   Instead, you simultaneously control both the \"mode\" that the <code>Level</code> is in, as well as <code>Level</code>'s value by choosing the appropriate subclass.  </p> <pre><code>INpc n = ...\n// Setting to straight level, with the Pc level Mult flag \"off\"\nn.Configuration.Level = new NpcLevel()\n{\nLevel = 10\n};\n\n// Setting to Pc Level Mult flag \"on\", now with float capabilities\nn.Configuration.Level = new PcLevelMult()\n{\nLevel = 2.1234f\n};\n</code></pre> <p>Now, it's very clear when <code>Level</code> is an integer, and when it is a float.  The flag's value and <code>Level</code>'s type are \"bundled\" as one choice, depending on which subclass you make.</p>"},{"location":"plugins/Abstract-Subclassing/#reading-an-abstract-subclass-member","title":"Reading an Abstract Subclass Member","text":"<p>Reading needs to respect/consider these subclasses in the same way.  One easy way to do this is using a C# type switch: <pre><code>INpcGetter n = ...\nswitch (n.Configuration.Level)\n{\ncase INpcLevelGetter straightLevel:\nSystem.Console.WriteLine($\"Npc level was {straightLevel.Level}\");\nbreak;\ncase IPcLevelMultGetter mult:\nSystem.Console.WriteLine($\"Npc level multiplier was {mult.Level}\");\nbreak;\ndefault:\nSystem.Console.WriteLine(\"Huh?\");\nbreak;\n}\n</code></pre></p> <p>Note that it is NOT good practice to do the following: <pre><code>INpcGetter n = ...\n// Bad code:\nint level = ((INpcLevelGetter)n.Configuration.Level).Level;\n</code></pre> This will break if you are processing an Npc with the <code>PC Level Mult</code> flag on, as the subobject won't be of type <code>INpcLevelGetter</code>.</p>"},{"location":"plugins/Abstract-Subclassing/#summary","title":"Summary","text":"<p>Abstract Subclassing is used when a concept is complex enough to warrant the need for extra control.  It often helps when a field's type can change based on the context, and it helps bundle the different typing WITH that context, so that there is no potential for desync.</p> <p>In the above example, you will never accidentally deal with a <code>Level</code> that is of type <code>float</code> unless it is in <code>Pc Level Mult</code> mode, and vice versa.  That is not the biggest deal, but in many other situations the concepts/differences are more extreme.</p>"},{"location":"plugins/Abstract-Subclassing/#other-records-with-abstract-subclassing","title":"Other Records with Abstract Subclassing","text":"<p>Skyrim Npc is not the only record type that uses these concepts.  There are many other records that have the need for data structure to change depending on context, and they will use Abstract Subclassing to help expose that.</p> <p>Some other examples include: Perk Effects</p> <p>These show a more extreme example where the fields that a Perk Effect contains vary widely depending on the Perk type.  The subclassing helps only expose the applicable fields for a given effect type.</p> <p>Magic Effects</p> <p>An effect can reference many different types of records, where some effect types can point to records of type ABC, while another effect type can only point to records of type XYZ.  The subclassing again helps expose only the correct typing depending on the effect type you're dealing with.</p>"},{"location":"plugins/Abstract-Subclassing/#documentation","title":"Documentation","text":"<p>Each subclassing situation is different and is trying to solve a different complexity specific to that record.  As things mature, documentation outlining each specific structure will probably be written.</p> <p>In the meantime, you can: - Utilize Intellisense, and follow references in the IDE to see the classes and what they contain. - Of importance:  The interfaces of these abstract classes contain comments of what options are available: <pre><code>/// &lt;summary&gt;\n/// Implemented by: [NpcLevel, PcLevelMult]\n/// &lt;/summary&gt;\npublic partial interface IANpcLevel\n{\n// ...\n}\n</code></pre> This helps narrow down which types it can be so you know what to switch on and handle. - Also, you can sometimes refer to the xmls that define the records, like the ones linked above.</p>"},{"location":"plugins/AssetLink/","title":"Asset Links","text":""},{"location":"plugins/AssetLink/#what-is-an-assetlink","title":"What is an AssetLink","text":"<p>An AssetLink is a strongly typed object wrapping what is normally a <code>string</code> subpath pointing to an asset.</p> <p>For example, a Skyrim Weapon's Model has a <code>File</code> member, which is the <code>MODL</code> subrecord, which contains a string relative to the <code>Data/Meshes</code> folder.   Rather than exposing this as a <code>string</code>, Mutagen exposes this as an <code>AssetLink&lt;SkyrimModelAssetType&gt;</code>.</p> <p>If you're just after the path, you can still get it via an AssetLink's <code>RawPath</code> member.  But the AssetLink now comes with a bunch of additional features and convenience</p>"},{"location":"plugins/AssetLink/#assetlink-members","title":"AssetLink Members","text":""},{"location":"plugins/AssetLink/#rawpath","title":"RawPath","text":"<p><code>RawPath</code> is the string that is present on disk in the record itself as it appears.  This is also the field that you can set when you want to modify an AssetLink to point to a different path.</p> <p><code>AssetLink</code>s are implicitly convertible to/from <code>string</code>, which uses <code>RawPath</code> as the string to return.  This is in place to provide some backwards compatibility</p>"},{"location":"plugins/AssetLink/#datarelativepath","title":"DataRelativePath","text":"<p><code>DataRelativePath</code> is a <code>get</code> only member that does some checking/trimming of <code>RawPath</code> to try to standardize it to be relative to a game's Data folder.</p> <p>It will trim a prefixed \"Data\" folder in the path, while also ensuring the appropriate asset subfolder is present.  Some examples:</p> RawPath DataRelativePath textures/some/subpath.nif textures/some/subpath.nif data/textures/some/subpath.nif textures/some/subpath.nif some/subpath.nif textures/some/subpath.nif <p>In all examples, the <code>DataRelativePath</code> remains the same, as that is what it's attempting to do: keep it standardized to be relative the Data folder, no matter the RawPath's contents.</p>"},{"location":"plugins/AssetLink/#assettypes-assetlinks-generic-type","title":"AssetTypes - AssetLink's Generic Type","text":"<p>An <code>AssetLink</code>'s generic type is the type of asset it relates to.  So, for example, a Skyrim Model path will be of type <code>AssetLink&lt;SkyrimModelAssetType&gt;</code>, where <code>SkyrimModelAssetType</code> is a meta class containing information about Skyrim Model assets: - <code>BaseFolder</code>, what subfolder underneath /Data/ these assests are expected to live - <code>FileExtensions</code>, what expected file extensions these types of meta files will have</p> <p>With this generic, each AssetLink knows that related information for the type of asset it is linking to.</p>"},{"location":"plugins/AssetLink/#asset-enumeration","title":"Asset Enumeration","text":"<p>Similar to FormLinks, a mod can enumerate AssetLinks of a desired type.   The details are slightly different, though.</p>"},{"location":"plugins/AssetLink/#typical-usage","title":"Typical Usage","text":"<pre><code>ILinkCache linkCache = ...;\n\nvar assetLinkCache = linkCache.CreateImmutableAssetLinkCache();\nforeach (var asset in assetContainer.EnumerateAllAssetLinks(assetLinkCache))\n{\n// Loops each asset\n}\n\n// Or typed\nforeach (var asset in assetContainer.EnumerateAllAssetLinks(assetLinkCache))\n{\n// Loops each asset\n}\n</code></pre>"},{"location":"plugins/AssetLink/#assetlinkquery","title":"AssetLinkQuery","text":"<p>This is a flag enum with three options, letting you control what type of Assets you want to enumerate: - <code>Listed</code>.  Assets explicitly listed in the records:   - Skyrim Model Path - <code>Inferred</code>.  Assets that can be inferred by fields that exist on the record   - Armor Addon World Model <code>_0</code> <code>_1</code> suffix assets   - Book text <code>src</code> links pointing to textures - <code>Resolved</code>.  Assets that can be inferred by looking at other records, and require FormLink lookups on a Link Cache.   - Dialog Topic's Voice Type paths </p> <p>By combining flags, you can control what Asset categories you are interested in.  There are also convenience methods like <code>EnumerateListedAssetLinks</code> that handle the flags for you.</p>"},{"location":"plugins/AssetLink/#iassetlinkcache","title":"IAssetLinkCache","text":"<p><code>Resolved</code> asset enumerations require an <code>IAssetLinkCache</code>.  This is due to their complex nature requiring a lot of work to locate the same data repeatedly, a cache object helps speed up the internal logic.</p>"},{"location":"plugins/AssetLink/#creating-an-asset-link-cache","title":"Creating an Asset Link Cache","text":"<p>An AssetLinkCache is a cache wrapper around LinkCache, to provide specific functionality for asset lookup.  You can make an AssetLinkCache from an ILinkCache, or call the extension method on a ILinkCache to get a new IAssetLinkCache <code>ILinkCache.CreateImmutableAssetLinkCache</code>.</p> <p>It is best to reuse the same Asset Link Cache for multiple queries, and recreate only if the wrapped LinkCache is invalidated.</p>"},{"location":"plugins/Binary-Exporting/","title":"Binary Exporting","text":""},{"location":"plugins/Binary-Exporting/#typical-export","title":"Typical Export","text":"<p>A basic mod write call is pretty straightforward: <pre><code>mod.WriteToBinary(desiredFilePath);\n</code></pre></p> <p>But the recommended call for exporting a mod has some extra parameters: <pre><code>mod.WriteToBinary(\n    desiredFilePath,\n    new BinaryWriteParameters()\n    {\n        MastersListOrdering = new MastersListOrderingByLoadOrder(loadOrder)\n    });\n</code></pre></p> <p>This extra information helps keep the masters in proper order, as the load order information is provided for the write call to use.  More information can be found about the details in the following sections.</p>"},{"location":"plugins/Binary-Exporting/#master-content","title":"Master Content","text":"<p>Mutagen automatically handles the logic to determine which masters are required.  It will iterate all records for: - Overridden </p>"},{"location":"plugins/Binary-Exporting/#master-ordering","title":"Master Ordering","text":"<p>Typically, the order that masters are written </p>"},{"location":"plugins/Binary-Exporting/#master-sync-options","title":"Master Sync Options","text":""},{"location":"plugins/Binary-Format-Complexity-Abstraction/","title":"Binary Format Complexity Abstraction","text":"<p>Bethesda's binary format contains a lot implementation complexities that are unrelated to the actual content of the records.  A lot of times the exposure of these details are a source of confusion, and don't add much upside in the way of flexibility or power into the hands of the user.  Mutagen attempts to abstract these complexities away so that the end user is dealing with the distilled record content more directly, rather than wading through the gritty specifics that only matter in the context of their binary format on disk.</p>"},{"location":"plugins/Binary-Format-Complexity-Abstraction/#formkeys-and-formlinks","title":"FormKeys and FormLinks","text":"<p>This topic was covered in detail in the ModKey, FormKey, FormLink section, and so will not be covered here.</p>"},{"location":"plugins/Binary-Format-Complexity-Abstraction/#record-types","title":"Record Types","text":""},{"location":"plugins/Binary-Format-Complexity-Abstraction/#four-character-headers","title":"Four Character Headers","text":"<p>Most seasoned modders are familiar with the 4 character record headers. <code>EDID</code> is <code>Editor ID</code>.  <code>FULL</code> is <code>Name</code>.  <code>MODL</code> is <code>Model</code>.  </p> <p>Most of these concepts are unnecessary in Mutagen.  Any member is exposed via its readable name: <code>npc.EditorID</code>, <code>npc.Name</code>, and <code>npc.Model</code>.  As such, there is no possibility of typos or misqueries, no need to remember the more obscure header strings, and no possibility of type mishandling.  Any typo or attempt to access a non-existent member will be caught by the compiler, instead of a failed string query at runtime.</p>"},{"location":"plugins/Binary-Format-Complexity-Abstraction/#alternate-headers","title":"Alternate Headers","text":"<p>Additionally, some common Record Types have alternate versions to denote different fields.  A common example of this is the <code>Model</code> Record Type <code>MODL</code>.</p> <p>(finish writing)</p>"},{"location":"plugins/Binary-Format-Complexity-Abstraction/#list-mechanics","title":"List Mechanics","text":""},{"location":"plugins/Binary-Format-Complexity-Abstraction/#item-storage","title":"Item Storage","text":"<p>There are a lot of varying ways that lists are stored in the binary format: - Repeated subrecords, with their Record Header as the delimiter.  Unknown amount.   (SPLO records in Oblivion) - Extra prepended subrecord /w the count of items in the list.  This can then be followed by repeated subrecords with Record Headers, or headerless raw data of known lengths.   (Keyword lists in Skyrim) - A Record Header for the list itself, followed immediately by a uint count, followed by undelimited content of known length. (Skyrim Model's Alternate Textures) - Probably others</p> <p>No matter what pattern is used for a specific set of records, they are all exposed via straight up lists in the API: <pre><code>// Oblivion spells\nIList&lt;FormLink&lt;Spell&gt;&gt; Spells { get; set; }\n\n// A keyword list\nIList&lt;FormLink&lt;Keyword&gt;&gt; Keywords { get; set; }\n\n// A model's alternate textures\nIList&lt;AlternateTexture&gt; AlternateTextures { get; set; }\n</code></pre></p>"},{"location":"plugins/Binary-Format-Complexity-Abstraction/#count-subrecords","title":"Count Subrecords","text":"<p>(finish writing)</p>"},{"location":"plugins/Binary-Format-Complexity-Abstraction/#globalgamesetting-types","title":"Global/Gamesetting types","text":"<p>The Global and Gamesetting records contain many different types of data while each having their own unique rules of communicating what type of data they contain.  For example, <code>Global</code> records have a special subrecord <code>FNAM</code> with a single char <code>i</code>, <code>f</code>, <code>s</code> to symbolize the float field it contains should be interpreted as an <code>int</code>, <code>float</code>, or <code>short</code>.  <code>GameSetting</code> on the other hand prepends a character to its EditorID to communicate what type of data is stored in its <code>DATA</code> subrecord.</p> <p>This complexity is abstracted away by Mutagen by offering strongly typed subclasses for Globals and Gamesettings.  <code>GlobalInt</code>, <code>GlobalFloat</code>, <code>GameSettingInt</code>, <code>GameSettingString</code>, <code>GameSettingBool</code>, etc.  These subclasses expose a strongly typed member of the correct type to the user while internally handling the most of the details.</p> <p>Creating a new Global/Gamesetting might look like: <pre><code>mod.Globals.Add(\nnew GlobalInt(mod.GetNextFormKey())\n{\nEditorID = \"AnIntGlobal\",\nData = 1234\n});\nmod.Globals.Add(\nnew GlobalFloat(mod.GetNextFormKey())\n{\nEditorID = \"AFloatGlobal\",\nData = 1234.5\n});\nmod.GameSettings.Add(\nnew GameSettingString(mod.GetNextFormKey())\n{\nEditorID = \"AStringGameSetting\",\nData = \"HelloWorld\"\n});\nmod.GameSettings.Add(\nnew GameSettingFloat(mod.GetNextFormKey())\n{\nEditorID = \"AFloatGameSetting\",\nData = 1234.5\n});\n</code></pre></p> <p>Note: For GameSettings, the EditorID stores the type data as its first character.  Any EditorID you set will automatically be processed to have the correct starting character.  As such, all GameSettings should have their EditorIDs set.</p> <p>Reading Globals/GameSettings consists of checking/casting the records to their correct subtype.  One easy way to do this is to use a switch: <pre><code>foreach (GameSetting setting in mod.GameSettings.Records)\n{\nswitch (setting)\n{\ncase GameSettingString stringSetting:\nSystem.Console.WriteLine($\"Found a string setting: {stringSetting.EditorID}\");\nSystem.Console.WriteLine($\"   Value: {stringSetting.Data}\");\nbreak;\ncase GameSettingBool boolSetting:\nSystem.Console.WriteLine($\"Found a bool setting: {stringSetting.EditorID}\");\nSystem.Console.WriteLine($\"   Value: {(stringSetting.Data ? \"ON!\" : \"OFF!\")}\");\nbreak;\n}\n}\n</code></pre></p>"},{"location":"plugins/Binary-Format-Complexity-Abstraction/#markers","title":"Markers","text":"<p>Some subrecords have specialized \"marker\" subrecords that precede them.  Sometimes they just mark the location of a section of subrecords, while other times they affect the context of the following subrecords.</p> <p>A good specific example can be found in Skyrim's <code>Race</code>'s Body Data subrecords.  A <code>Race</code> has a body data struct for males, and a body data struct for females.  These records are first \"marked\" by an empty <code>NAM0</code> record.  They are then further \"marked\" by empty <code>MNAM</code> or <code>FNAM</code> subrecords, to indicate if the following data is for males or females.  The binary might follow this pattern: <pre><code>NAM0: No content, just a marker\nMNAM: No content, just a marker\nINDX: Body Data content for males\nMODL: Body Data content for males\nFNAM: No content, just a marker\nINDX: Body Data content for females\nMODL: Body Data content for females\n</code></pre></p> <p>Mutagen abstracts the concepts of markers away from the user completely.  No concepts of markers exist in the API exposed.  A user can just directly access the data they're interested in, and if a marker-related field is set for exporting, the marker systems will be handled automatically during export internally.</p>"},{"location":"plugins/Binary-Format-Complexity-Abstraction/#pathgrid-point-zipping","title":"PathGrid Point Zipping","text":"<p>Path grid information in records such as Oblivion's <code>Road</code> are stored in two separate subrecord lists that need to be considered together in order to get the complete structure.  The points themselves are stored in the list <code>PGRP</code>, while the information about the connections between points is stored in <code>PGRR</code>.  If you want to know what points have what connections, you need to offset your queries into the <code>PGRR</code> subrecord properly.  Each Point exposes the number of connections it has.  Then, to find the connections for Point #7, you have to offset your query into <code>PGRR</code> by 12 * the number of connections Points #1-6 had.  You then have to extract the number of connection floats appropriate for Point #7, based on the number of connections it says it has.</p> <p>Mutagen abstracts this \"zipping\" work for you and offers a simple <code>IList&lt;RoadPoint&gt; Points;</code> member on <code>Road</code>.  Each <code>RoadPoint</code> has a <code>IList&lt;P3Float&gt; Connections;</code> with all the connections related to that point.  All the complexity of the dual subrecords is hidden from the user, and they can just manipulate these lists directly in a more straightforward and familiar fashion.</p>"},{"location":"plugins/Binary-Format-Complexity-Abstraction/#multiple-flag-consolidation","title":"Multiple Flag Consolidation","text":"<p>Some records have so many flags that they overflow above the typical 4 bytes.  Bethesda will then put a second set of flags elsewhere in the record with the overflow flag values.  One example of this happening is in Skyrim's Race record.  Mutagen merges the overflow into one Flag field exposing all of the values in one place.</p>"},{"location":"plugins/Binary-Format-Complexity-Abstraction/#gendereditem","title":"GenderedItem","text":"<p>Bethesda records have a lot of fields that come in a Male/Female pair.  While not too much of a problem by itself, most of the complexity comes in the variety of ways that these pairs can be organized.  Sometimes the M/F data is held in dedicated <code>MNAM</code>/<code>FNAM</code> records.  Sometimes those records are prepended by a marker, as mentioned above.  Sometimes instead both are found in a single subrecord, with the data just back to back.</p> <p>Mutagen standardizes all the various cases, and exposes the male/female alternatives using a <code>GenderedItem</code> struct in the public API: <pre><code>public class GenderedItem&lt;T&gt;\n{\n    public T Male { get; set; }\n    public T Female { get; set; }\n}\n\n...\n\n// Using Oblivion's Race's Height as an example\nrace.Height.Male = 1.5f;\nfloat femaleHeight = race.Height.Female;\n</code></pre></p>"},{"location":"plugins/Binary-Format-Complexity-Abstraction/#pseudo-enum-dictionaries","title":"Pseudo Enum Dictionaries","text":"<p>Skyrim's Race record has a hacky binary implementation for its <code>Biped Object Names</code> field.</p> <p>This field is supposed to expose the names associated with the different values of this enum: <pre><code>[Flags]\npublic enum BipedObjectFlag : uint\n{\n    Head = 0x0000_0001,\n    Hair = 0x0000_0002,\n    Body = 0x0000_0004,\n    ...\n    Ears = 0x0000_2000,\n    DecapitateHead = 0x0010_0000,\n    Decapitate = 0x0020_0000,\n    FX01 = 0x8000_0000,\n}\n</code></pre></p> <p>With this field, a user can specify different string names for the Head slot, the Hair slot, etc.  Oddly, though, this is all stored as a list, where the 3rd item would be associated with the <code>Body</code>, for example.  Additionally, to get out to the later enum values, empty list items must be inserted for each unknown flag index.</p> <pre><code>// Example binary structure\nNAME - \"Top Thing\"  // Head index\nNAME - \"Inedible Spaghetti\" // Hair index\nNAME - \"Gut Housing\" // Body index\n...\nNAME - \"Future Wings\" // Ear index\nNAME - empty // Empty index for 0x0000_4000\nNAME - empty // Empty index for 0x0000_8000\n...\nNAME - empty // Empty index for 0x0008_0000\nNAME - \"Decapitate Head\" // Decapitate Head index\n</code></pre> <p>Notice that the user needs to coordinate/know that the third index is the body index.  They also need to make sure to insert/count the proper empty indices in order to \"reach\" the later flags.  If any item is inserted/removed, all the surrounding items are now misaligned, etc.</p> <p>Mutagen wraps these List concepts internally, and exposes <code>Dictionary&lt;BipedObjectFlag, string&gt;</code> in its public API instead.  The user can get/set the dictionary in a more natural way, and the error prone list implementation will be handled for them under the hood.</p>"},{"location":"plugins/Binary-Importing/","title":"Binary Importing","text":"<p>All Mods are generated with the ability to create themselves from their binary format.</p>"},{"location":"plugins/Binary-Importing/#basic-importing","title":"Basic Importing","text":"<p><pre><code>string path = \"C:/Steam/blah/blah/Oblivion.esm\";\nOblivionMod mod = OblivionMod.CreateFromBinary(path);\n</code></pre> At this point, the entire mod will have been loaded into memory via classes created to store all the various fields and records.   You can then begin to interact with the mod object.  </p>"},{"location":"plugins/Binary-Importing/#group-masks","title":"Group Masks","text":"<p>Normally, users are not interested in ALL records that a mod contains.  Group Masks are an optional parameter that allows you to specify which record types you are interested in importing. <pre><code>string path = \"C:/Steam/blah/blah/Oblivion.esm\";\nvar mod = OblivionMod.CreateFromBinary(\npath,\nimportMask: new GroupMask()\n{\nPotions = true,\nNPCs = true,\n}); </code></pre> This import call will only process and import Potions and NPCs.</p>"},{"location":"plugins/Binary-Importing/#notes","title":"Notes","text":"<p>While these basic import features sounds fundamental, they are overshadowed and depreciated somewhat by the Binary Overlay concepts.</p>"},{"location":"plugins/Binary-Overlay/","title":"Binary Overlay","text":"<p>Binary Overlays are an alternative to the more simplistic Binary Importing concepts.</p>"},{"location":"plugins/Binary-Overlay/#reasoning-for-an-alternate-pattern","title":"Reasoning for an Alternate Pattern","text":""},{"location":"plugins/Binary-Overlay/#memory-usage-is-frontloaded","title":"Memory Usage is Frontloaded","text":"<p>One of the downsides of typical importing is that all the data must be read into an object upfront and continues existing in memory until the object is released to the GC.  Many operations only want to process each record once and then move on.  They do not need all the records to exist in memory at the same time and would actually prefer if they weren't.</p>"},{"location":"plugins/Binary-Overlay/#user-must-specify-interest","title":"User Must Specify Interest","text":"<p>Additionally, the user must specify to the import function all of the record types that they are interested in.  Otherwise, the import function will parse and create records for everything in the mod, wasting time and memory usage.  If the user fails to list a record type, but then proceeds to query for them, then bugs can occur.</p>"},{"location":"plugins/Binary-Overlay/#all-records-are-parsed-for-interest-groups","title":"All Records are Parsed (for Interest Groups)","text":"<p>When a specific Group is marked for interest and imported, all aspects of those Records are parsed and created in memory with no regard to whether the user will actually make use of them all.  This is a lot of wasted work and memory usage for data that will go unused.</p>"},{"location":"plugins/Binary-Overlay/#introduction-to-overlay-concepts","title":"Introduction to Overlay Concepts","text":"<p>The Binary Overlay concept is an alternate method of importing/reading mods in an on-demand and transient way.  One of its main features is that only fields that are accessed get parsed, which saves a lot of time and work.</p> <p><pre><code>using var mod = OblivionMod.CreateFromBinaryOverlay(pathToMod);\n// Code accessing the mod\n</code></pre> Some differences:</p>"},{"location":"plugins/Binary-Overlay/#it-returns-a-getter-interface","title":"It returns a <code>Getter</code> interface.","text":"<p>You can only read from an overlay.  You cannot modify it.</p>"},{"location":"plugins/Binary-Overlay/#requires-an-open-stream","title":"Requires an open Stream","text":"<p>Binary Overlays keep reference to an open stream internally, so they can read it as appropriate.  This helps parse things in a lazy fashion, so that only the applicable data is processed and in-memory.  Binary Overlay objects implement <code>IDisposable</code>, which closes the stream when they are disposed.  Putting them in <code>using</code> statements to close when appropriate is good practice.</p>"},{"location":"plugins/Binary-Overlay/#no-up-front-parsing-work","title":"No Up Front Parsing Work","text":"<p>With the overlay pattern, a mod object is returned almost immediately for use after having done almost no parsing.  As the user accesses members of the <code>Mod</code>, the parsing is done on demand for only the members accessed.</p>"},{"location":"plugins/Binary-Overlay/#no-persistent-references-to-records-or-memory","title":"No Persistent References to Records or Memory","text":"<p>Binary Overlays keep no internal references to any record objects.  This means that when a user is done working with something and discards it, the GC is allowed to immediately clean it up.</p>"},{"location":"plugins/Binary-Overlay/#concrete-example","title":"Concrete Example","text":"<p>It might be useful to walk through a concrete example, and some of the mechanics going on under the hood.  Consider this code: <pre><code>using (IOblivionModGetter mod = OblivionMod.CreateFromBinaryOverlay(pathToMod))\n{\nforeach (var potion in mod.Potions.Records)\n{\n// Check if the record has an EditorID, and get it\nif (!potion.EditorID.TryGet(out var edid)) continue;\n// Print the result\nSystem.Console.WriteLine(edid);\n}\n}\n</code></pre> This code is intended to print each Potion's Editor ID to the console.</p>"},{"location":"plugins/Binary-Overlay/#what-work-is-actually-done-by-this-code","title":"What work is actually done by this code?","text":"<ul> <li>A file is opened</li> <li>An overlay class that implements <code>IOblivionModGetter</code> and has a reference to the file stream is instantiated.</li> <li>Quick skip-over parsing of the file is done to locate the locations of the Groups.</li> <li>User accesses the Potion Group.</li> <li>A Group overlay object is created, and the Potion Group's raw bytes are read from the file.</li> <li>Group overlay object marks all locations of Potion records in its data.</li> <li>User loops over all Potions in the Group.</li> <li>For each loop iteration, an <code>IPotionGetter</code> overlay object is created, pointing to the memory location for that record.</li> <li>The potion overlay object marks the location of all subrecords it contains.</li> <li>The user retrieves the EditorID (once), and checks if is set.</li> <li>The EDID subrecord is parsed from the byte array as a string and returned.</li> <li>The string is printed to the console.</li> <li>After loop is over, the stream is closed.</li> </ul>"},{"location":"plugins/Binary-Overlay/#what-are-some-things-that-were-not-done","title":"What are some things that were not done?","text":"<ul> <li>No Groups besides Potion were parsed. Their top level locations were noted, but no contents were processed.</li> <li>No subrecords were parsed, except EditorID (EDID).</li> <li>No object had a reference to all the Potion records, so as to keep their contents in memory.  The Group object simply has a list of locations.  The user has the only reference to any Potion record at any given moment, and as soon as they were done with it was cleaned up.</li> <li>No extra code was written by the user to help indicate they were only interested in Potions or EditorIDs.  Writing code that accessed them was the implicit indication of interest itself.</li> </ul>"},{"location":"plugins/Binary-Overlay/#summary-overview","title":"Summary Overview","text":"<p>The Binary Overlay concept is a powerful tool that can be used for vast speed/memory improvements for certain jobs.  It is suggested for use in most importing scenarios.  Actual normal record objects should generally be reserved for use when constructing new/modified records for output.</p>"},{"location":"plugins/Binary-Overlay/#pros","title":"Pros","text":"<ul> <li>Much faster as there is no parsing of fields that are not used.</li> <li>No need to specify ahead of time which records will be used.</li> <li>Much lower memory footprint as records only exist as the user is interacting with them.</li> </ul>"},{"location":"plugins/Binary-Overlay/#cons","title":"Cons:","text":"<ul> <li>The source stream must remain open for the lifetime of the overlay.</li> <li>Any access of the mod or group objects can only be done if the stream is open.</li> <li>Overlays are readonly, so copies to new objects must be made if user wishes to modify contents.</li> <li>Parsing is done on access, which means repeated accesses means multiple parsing of the same data.  </li> </ul>"},{"location":"plugins/Binary-Overlay/#best-practices","title":"Best Practices","text":"<p>As noted above, the Overlay pattern has the downside that repeated access of properties means repeated parsing of the same data.  While this may sound scary at first, it shouldn't pose much of a problem in most scenarios as parsing is very quick.  Most caching solutions that attempt to \"fix\" this quality will probably be slower and come with the additional downside of bloating memory usage.</p> <p>However, this parse-per-access quality does encourage a slightly different coding pattern if you want to squeeze out the tiniest optimization.  Ideally you still want to access properties as little as possible when you can.  Here are some suggestions and tricks:</p>"},{"location":"plugins/Binary-Overlay/#example-of-misuse","title":"Example of Misuse","text":"<p>Here is an example of very slight misuse (only when using an Overlay): <pre><code>if (npcOverlay.EditorID != null)\n{\nSystem.Console.WriteLine($\"NPC's EditorID was: {npcOverlay.EditorID}\");\n}\n</code></pre></p> <p>Why is this bad practice?  Because <code>npcOverlay.EditorID</code> was accessed twice, and so the byte to string parsing for EditorID was executed twice.  In reality, this isn't the biggest deal as it's a small amount of data, and the parsing is extremely quick.  But we're here to talk about optimization and best practices.</p>"},{"location":"plugins/Binary-Overlay/#save-to-variable","title":"Save to Variable","text":"<p>One simple way to reduce access calls when you know you're going to be doing several in a row is to just save the single access to a variable: <pre><code>var editorID = npcOverlay.EditorID;\nif (editorID != null)\n{\nSystem.Console.WriteLine($\"NPC's EditorID was: {editorID}\");\n}\n</code></pre> This is a simple way to remove the redundant access/parse.</p>"},{"location":"plugins/Binary-Overlay/#group-access-special-case","title":"Group Access Special Case","text":"<p>Accessing a Group on a binary overlay mod object is a special case that is even more expensive.  The mod objects are designed to open the file and read the contents from disk at the Group level.  Compared to normal records/fields which multiple accesses will just result in parsing the same memory twice, multiple accesses of the same group will result in multiple reads of the content off the disk.  This is much slower.  </p> <p>As such, Groups should receive extra care to only access them once.  As a simple example using the tip describe above: <pre><code>var overlayMod = ...;\n\n// Retrieve the group once\nvar npcs = overlayMod.Npcs;\n\nforeach (var thing in things)\n{\n// Use the same variable many times\nif (npcs.TryGetValue(thing.FormKey, out var record))\n...\n}\n</code></pre></p>"},{"location":"plugins/Binary-Overlay/#pattern-matching","title":"Pattern Matching","text":"<p>It is a very common pattern that a member might not be set.  An alternate way of dealing with this is via Pattern Matching: <pre><code>if (npcOverlay.EditorID is string editorID)\n{\nSystem.Console.WriteLine($\"NPC's EditorID was {editorID}\");\n}\n</code></pre></p> <p>This provides a nice if-exists-then-do pattern, where <code>EditorID</code> is only parsed once and its result exposed in a non-null <code>string</code> variable to use inside the if statement.</p> <p>If you want a more <code>var</code>-like behavior, you can also consider this pattern <pre><code>if (npcOverlay.EditorID is {} editorID)\n{\n    System.Console.WriteLine($\"NPC's EditorID was {editorID}\");\n}\n</code></pre></p> <p>You no longer need to specify the type <code>string</code>, but it's an odd looking pattern.  C# might introduce a better looking one in the future.</p>"},{"location":"plugins/Binary-Overlay/#safe-navigation-operator","title":"Safe Navigation Operator","text":"<p>In C#, a call on a potentially null member can be short circuited easily by adding a Safe Navigation Operator (<code>?</code>).  This does a null check, and only calls the function or retrieves the data if it is not null.  Here's how it might be used: <pre><code>System.Console.WriteLine($\"NPC's EditorID was {npcOverlay.EditorID?.ToString()}\");\n</code></pre> <code>ToString()</code> is only called if EditorID is not null.  It has the upside of only accessing the property once before calling the function, and so is proper practice when calling functions on Overlay members that could be null.</p>"},{"location":"plugins/Binary-Overlay/#null-coalescing-operator","title":"Null Coalescing Operator","text":"<p>Another common operator related to potentially null items is the Null Coalescing operator (<code>??</code>).  This checks if an item is null, and if so, returns a second value. <pre><code>System.Console.WriteLine($\"NPC's EditorID was {npcOverlay.EditorID ?? \"UNKNOWN\"}\");\n</code></pre> This will access and return EditorID, unless it is null, at which point \"UNKNOWN\" will be returned and printed.  It also has the upside of only accessing the property once before calling the function, and so is proper practice when accessing Overlay members that could be null.</p>"},{"location":"plugins/Copy-Functionality/","title":"Copy Functionality","text":"<p>Mutagen provides functionality for copying in data to an already existing object.</p>"},{"location":"plugins/Copy-Functionality/#deepcopy","title":"DeepCopy","text":"<p>This call will create a new object, and copy all fields.  This will be done in a \"deep\" fashion, where duplicate objects will be made for each subobject and their fields copied over as well.  No references to the original object or any subobjects from the original will exist in the object copied to.</p> <p>This separates the new object from the original object so that modifying either has no effect on the other.</p> <pre><code>IPotionGetter potionSource = ...;\nPotion potionCopy = (Potion)potionSource.DeepCopy();\n</code></pre> <p>Some things to note: - FormKey will match the original source - Changes to either object will not affect the other - The new record will not be a part of any Mod or Group unless added explicity. - The cast is required currently, but will hopefully be unnecessary eventually.</p>"},{"location":"plugins/Copy-Functionality/#deepcopyin","title":"DeepCopyIn","text":"<p>This call will copy in all fields from a second object to an already existing object</p> <pre><code>IPotionGetter potionSource = ...;\nPotion potionCopy = mod.Potions.AddNew();\npotionCopy.DeepCopyIn(potionSource);\n</code></pre> <p>Some things to note: - <code>FormKey</code>s are immutable, and will never be changed even with a copy in.  If you want a second record with the original's <code>FormKey</code>, use DeepCopy instead. - Changes to either object will not affect the other</p>"},{"location":"plugins/Copy-Functionality/#translation-masks","title":"Translation Masks","text":"<p>As with many other translational tasks in Mutagen, Copy functionality comes with the option to provide Masks to control what will get copied.</p> <p><pre><code>var onlyScriptsMask = new Potion.TranslationMask(defaultOn: false)\n{\nScript = true\n};\n\npotion.DeepCopyIn(otherPotion, onlyScriptsMask);\n</code></pre> This code will replace <code>potion</code>'s script data with the values from <code>otherPotion</code>.  All other subrecords will remain untouched.</p>"},{"location":"plugins/Copy-Functionality/#copyinfrombinary","title":"CopyInFrom[Binary]","text":"<p>In addition to being able to copy in fields from another object via DeepCopyIn, you can also CopyIn from other serialization sources such as from a Binary file on the disk.</p> <p>This mainly only applies to Mod objects, rather than individual Major Records.  It is also less granular than other translation sources, and only lets you mask per Group type.</p> <pre><code>OblivionMod mod = ...;\nmod.CopyInFromBinary(\npath: \"C:/SomePath/SomeMod.esp\",\nimportMask: new GroupMask(false)\n{\nNPCs = true\n});\n</code></pre> <p>This code will replace the <code>mod</code> object's NPC Group's contents with the NPC contents from the file on disk.</p>"},{"location":"plugins/Create%2C-Duplicate%2C-and-Override/","title":"Create, Duplicate, and Override","text":""},{"location":"plugins/Create%2C-Duplicate%2C-and-Override/#create-new-records","title":"Create New Records","text":"<p>New records can be constructed in a few ways.  Note that a record's FormKey is required during construction, and immutable.  If you want to change the FormKey of a record, a new one should be made.  Any desired fields can be brought over via CopyIn mechanics.</p>"},{"location":"plugins/Create%2C-Duplicate%2C-and-Override/#by-constructor","title":"By Constructor","text":"<p>Any standalone record can be made by using its constructor. <pre><code>// Verbose example, showing all the components\nvar modKey = ModKey.Factory(\"Oblivion\", master: true);\nvar formKey = new FormKey(modKey, 0x123456);\nvar potion = new Potion(formKey);\n</code></pre></p>"},{"location":"plugins/Create%2C-Duplicate%2C-and-Override/#from-a-mods-group","title":"From a Mod's Group","text":"<p>If you have an <code>IMod</code> object that you want the record to originate from, you can easily make one from the corresponding <code>Group</code>. <pre><code>var potion = mod.Potions.AddNew();\n</code></pre> The new record will have the next available <code>FormKey</code> from that mod based on the metadata in its header, and automatically be added to the Group it originated from.  Note this is not applicable to Binary Overlays, as they are getter only interfaces, so this concept is not applicable.  This is instead meant for new Mod objects that have been created for the purpose of modification and eventual export.</p>"},{"location":"plugins/Create%2C-Duplicate%2C-and-Override/#by-duplication","title":"By Duplication","text":"<p>Duplicating a record is the equivalent of creating a fresh record, and then copying in data to match a different record.  This can be done via CopyIn API, but there are some convenience methods for this as well</p> <pre><code>INpcGetter sourceNpc = ...;\n// Add a new record with a new FormKey to our mod, with the given record's data\nvar copy = myMod.Npcs.DuplicateInAsNewRecord(sourceNpc);\n// Modify the name of our new separate record\ncopy.Name = \"My Name\";\n</code></pre>"},{"location":"plugins/Create%2C-Duplicate%2C-and-Override/#overriding-records","title":"Overriding Records","text":"<p>It is very common to want to modify a record that is from another mod.  This just entails making a copy of the original record and adding it to your output mod.  The fact that the FormKey doesn't originate from your output mod implicitly means that it's an override.</p>"},{"location":"plugins/Create%2C-Duplicate%2C-and-Override/#getoraddasoverride","title":"GetOrAddAsOverride","text":"<p>The quick any easy way to override a record is to utilize a Group.GetOrAddAsOverride call.  This will check if the record already exists as an override in your group, and return it if so.  Otherwise, it will copy the source record to a new object, and add it to your mod for you. <pre><code>INpcGetter sourceNpc = ...;\n// Retrieve or copy-and-add the record to our mod\nvar override = myMod.Npcs.GetOrAddAsOverride(sourceNpc);\n// Modify the name to be different inside myMod\noverride.Name = \"My New Name\";\n</code></pre></p> <p>NOTE:  With this pattern, it is preferable to call <code>GetOrAddAsOverride</code> as late as possible, after all filtering has been done and you know you want to override and modify the record.  This avoids adding records to your mod that have no changes.</p>"},{"location":"plugins/Create%2C-Duplicate%2C-and-Override/#deep-copy-then-insert","title":"Deep Copy Then Insert","text":"<p>This pattern is an alternative to <code>GetOrAddAsOverride</code>.  It is sometimes preferable if it's hard to delay the <code>GetOrAddAsOverride</code> call, and you want more control over when a record actually gets added to the outgoing mod.</p> <pre><code>INpcGetter sourceNpc = ...;\n// Make a new mutable object that is a copy of the record to override\nvar npcCopy = sourceNpc.DeepCopy();\n// Modify the name\nnpcCopy.Name = \"My New Name\";\n// Add the record to the mod we want to contain it\n// Note that the copy has the same FormKey as the original, so it's considered an \"override\" when added to\n// a new mod that will be loaded after it\noutputMod.Npcs.Add(npcCopy);\n</code></pre> <p>This strategy works well if you might change your mind and not add the copied record to the outgoing mod.  It lets you get a mutable version of the record without adding it to your outgoing mod until you are certain you want to include it.</p>"},{"location":"plugins/Create%2C-Duplicate%2C-and-Override/#nested-records","title":"Nested Records","text":"<p>Some records like Placed Objects and Cells are often nested underneath other records.  This makes it harder to follow the above patterns.  For these you will want to make use of the [../linkcache/ModContexts.md] concepts.</p>"},{"location":"plugins/Equality-Checks/","title":"Equality Checks","text":""},{"location":"plugins/Equality-Checks/#basic-equality","title":"Basic Equality","text":"<p>Mutagen generates Equals and Hash functions for all classes based on record content.  Normal C# equality checks can be used: <pre><code>bool isEqual = npc1.Equals(npc2);\nbool isEqual2 = object.Equals(npc1, npc2);\nint hash = npc1.GetHashCode();\n</code></pre></p>"},{"location":"plugins/Equality-Checks/#equals-mask","title":"Equals Mask","text":"<p>Mutagen generates additional helper classes called \"Masks\".  These can be used to help specify what fields a user wants to check for equality, or hash with. <pre><code>// Create a mask that will only check EditorID and Name\nNPC.Mask&lt;bool&gt; mask = new NPC.Mask(initialValue: false)\n{\nEditorID = true,\nName = true,\n}\n\nbool isEqual = npc1.Equals(npc2, mask);\nint hash = npc1.GetHashCode(mask);\n</code></pre></p> <p>A user can also check equality and get a Mask back as the return value: <pre><code>NPC.Mask&lt;bool&gt; equalsMask = npc1.GetEqualsMask(npc2);\nbool isEditorIdEqual = equalsMask.EditorID;\nbool isNameEqual = equalsMask.Name;\nbool allFieldsEqual = equalsMask.AllEqual(isEqualBool =&gt; isEqualBool);\n</code></pre></p>"},{"location":"plugins/Flags-and-Enums/","title":"Flags and Enums","text":"<p>A lot of Record data is exposed via flags and enums.  All of known enum types and their options are defined explicitly for strongly typed use.</p>"},{"location":"plugins/Flags-and-Enums/#normal-enum","title":"Normal Enum","text":"<p>Certain fields have a certain subset of valid options.  These are exposed as enums, where only one choice can be made.</p> <p>For example, Oblivion's <code>Creature</code> has an enum that looks like this: <pre><code>public enum CreatureTypeEnum\n{\nCreature = 0,\nDaedra = 1,\nUndead = 2,\nHumanoid = 3,\nHorse = 4,\nGiant = 5,\n}\n</code></pre></p> <p>As a user, you can set the desired value by referencing this enum <pre><code>creature.CreatureType = CreatureTypeEnum.Undead;\n</code></pre></p> <p>You can also read the enum and do things like switch: <pre><code>switch (creature.CreatureType)\n{\ncase CreatureType.Creature:\nbreak;\ncase CreatureType.Daedra:\nbreak;\ncase CreatureType.Undead:\nbreak;\ncase CreatureType.Humanoid:\nbreak;\ncase CreatureType.Horse:\nbreak;\ncase CreatureType.Giant:\nbreak;\n}\n</code></pre></p>"},{"location":"plugins/Flags-and-Enums/#unknown-flags","title":"Unknown Flags","text":"<p>Enums only list the values that are known and have \"nicknames\".  Sometimes mods have values for things that are \"unknown\" and don't have a name.   Rather than listing these, Mutagen opts to only list known values to keep things clean.</p> <p>You can still get at and set these values, though.  Enums in C# are backed by <code>int</code> (or other numeric primitives), and so you can write code like this: <pre><code>CreatureType e = (CreatureType)13; if (e == (CreatureType)13)\n{\n\n}\n</code></pre></p> <p>With this style API, you can still access all unknown values as needed.</p>"},{"location":"plugins/Flags-and-Enums/#flags-enum","title":"Flags Enum","text":"<p>Certain fields are allowed to have several values, and so make use of C#'s flags enum systems.</p> <p>For example, Oblivion <code>NPC</code>'s flags look like this: <pre><code>[Flags]\npublic enum NPCFlag\n{\nFemale = 0x000001,\nEssential = 0x000002,\nRespawn = 0x000008,\nAutoCalcStats = 0x000010,\n...\n}\n</code></pre></p> <p>This enum can then be used to specify several flags on an NPC: <pre><code>// Mark the NPC an essential female\nnpc.Flags = NPCFlag.Female | NPCFlag.Essential;\n\n// And then add that we also want it to auto calc stats\nnpc.Flags |= NPCFlag.AutoCalcStats;\n</code></pre></p> <p>You can read up on C# flag enums on stack overflow for more API tricks.</p> <p>In addition to the built in C# features, Mutagen has some helper methods such as <pre><code>npc.Flags = npc.Flags.SetFlag(NPCFlag.AutoCalcStats, true);\n\nif (npc.Flags.HasFlag(NPCFlag.AutoCalcStats))\n{\n}\n</code></pre> These aren't included in C# by default, but are part of the Mutagen ecosystem.</p>"},{"location":"plugins/FormKey-Allocation-and-Persistence/","title":"FormKey Allocation and Persistence","text":"<p>It is common that tooling that is generating new records when creating plugins wants to keep their FormKeys consistent across several runs.  The same records should get the same FormKeys.</p> <p>There are some challenges with fulfilling this: - How is a record detected to be the \"same\" as one from a previous run? - Where/How do you persist the mapping information between runs?</p>"},{"location":"plugins/FormKey-Allocation-and-Persistence/#mapping-records-via-editorid","title":"Mapping Records Via EditorID","text":"<p>One of the challenges is finding a way to map records from a previous run with records from the current run, so that their FormKeys can be synced.  Mutagen does this by requiring the developer provide a unique EditorID when they want syncing to occur.</p> <p>Mutagen offers a few ways to hook into its allocation API. <pre><code>// No EditorID is provided at time of creation, so no syncing features invoked\nvar unsyncedNpc = mod.Npcs.AddNew();\n\n// EditorID is provided, so FormKey syncing features are active for this record\nvar syncedNpc = mod.Npcs.AddNew(\"SomeUniqueEdid\");\n\n// Some more routes\nvar syncedNpc2 = new Npc(mod, \"SomeThirdEdid\");\nvar syncedNpc3 = new Npc(mod.GetNextFormKey(\"SomeOtherEdid\"));\n</code></pre></p> <p>For the records where the EditorID was provided at the time of creation, syncing functionality will be applied if enabled (more on this later).</p>"},{"location":"plugins/FormKey-Allocation-and-Persistence/#keep-editorids-unique","title":"Keep EditorIDs Unique","text":"<p>With this pattern, the burden is on the developer to ensure that all records created in this fashion are supplied unique EditorIDs.  If new record is made with an EditorID that has already been used in the current \"run\", then an exception will be thrown.</p> <p>It is recommended to name the EditorIDs off the aspects that drove the record to be made in the first place:</p> <p><code>MyMod_GlassArmorNoviceShockEnchantment</code></p> <p><code>MyMod_GlassArmorMasterShockEnchantment</code></p> <p>Since each is named with a specific \"goal\" in mind, it will be less likely to collide.</p>"},{"location":"plugins/FormKey-Allocation-and-Persistence/#persistence-and-allocation","title":"Persistence and Allocation","text":"<p>The other half that needs to be considered is where the mapping information is stored, and how that data gets imported/used to fulfill the allocation requests described above.</p>"},{"location":"plugins/FormKey-Allocation-and-Persistence/#setting-a-mods-allocator","title":"Setting a Mod's Allocator","text":"<p>Every mod can have its FormKey allocator set, which is the logic that hands out new FormKeys to records.  This where a FormKey syncing allocator can be injected with whatever behavior we wish.</p> <p><pre><code>var mod = new SkyrimMod(...);\nvar allocator = new TextFileFormKeyAllocator(mod, pathToFile);\nmod.SetAllocator(allocator);\n</code></pre> This would set the mod to sync its FormKeys to a text file at the given path.</p>"},{"location":"plugins/FormKey-Allocation-and-Persistence/#text-file-allocators","title":"Text File Allocators","text":"<p>These alloctors save their data into a text file with the following format: <pre><code>TheEditorIdToSyncAgainst\n123456\n[...Repeat...]\n</code></pre></p> <p>One thing of note is that it saves just the FormID, without the mod indices.  The ModKey to be associated with is not persisted in the file itself.</p>"},{"location":"plugins/FormKey-Allocation-and-Persistence/#textfileformkeyallocator","title":"TextFileFormKeyAllocator","text":"<p>This a simplistic 1:1 allocator from a single mod to a single file.  As such, the ModKey of the mod is combined with the FormID retrieved from the file to get the actual FormKey for use.</p> <pre><code>var mod = new SkyrimMod(...);\nvar allocator = new TextFileFormKeyAllocator(mod, pathToFile);\nmod.SetAllocator(allocator);\n</code></pre>"},{"location":"plugins/FormKey-Allocation-and-Persistence/#textfilesharedformkeyallocator","title":"TextFileSharedFormKeyAllocator","text":"<p>This is a more advanced allocator for when several separate sources need to coordinate together to avoid FormKey collisions.  A prime example is a Synthesis patcher run, where several separate programs will run, and all need to avoid allocating FormKeys that another has used.</p> <pre><code>var mod = new SkyrimMod(...);\nvar allocator = new TextFileSharedFormKeyAllocator(mod, pathToFolder, \"MyProgramName\");\nmod.SetAllocator(allocator);\n</code></pre> <p>This will save to a folder, instead, with a file within under \"MyProgramName\" that has this specific programs sync information.  However, the system will examine other files within that folder so that those FormKeys can be avoided when allocating fresh new FormKeys.</p>"},{"location":"plugins/FormKey-Allocation-and-Persistence/#sqlite","title":"Sqlite","text":"<p>There is also the beginnings of a Sqlite backed persistence system within <code>Mutagen.Bethesda.Sqlite</code>.  It needs to be optimized before it will be a viable choice.</p>"},{"location":"plugins/FormKey-Allocation-and-Persistence/#saving-allocation-state","title":"Saving Allocation State","text":"<p>Allocators are created separately from a mod, even if they are assigned to a mod and tightly associated with it.  As such, allocators are themselves in charge of persisting their state once allocations have been made.  Typically this is done via disposal mechanics:</p> <pre><code>var mod = new SkyrimMod(...);\n// This API pattern will dispose the allocator when its variable goes out of scope\nusing var allocator = new TextFileFormKeyAllocator(mod, pathToFile);\nmod.SetAllocator(allocator);\n\n// Or\nvar mod2 = new SkyrimMod(...);\nusing (var allocator2 = new TextFileFormKeyAllocator(mod, pathToFile))\n{\nmod2.SetAllocator(allocator2);\n// Do work on mod\n} // Allocator exports results to disk here\n\n// Or\nvar mod3 = new SkyrimMod(...);\nvar allocator3 = new TextFileFormKeyAllocator(mod, pathToFile)\nmod3.SetAllocator(allocator3);\n\n// Do work on mod\n// Manually dispose or persist allocator when done\nallocator3.Commit(); // Or Dispose\n</code></pre>"},{"location":"plugins/Generated-Classes/","title":"Generated Classes","text":"<p>Mutagen provides C# classes, as well as matching interfaces for all records it supports.</p> <p>Here's an example of what an interface for the <code>Potion</code> record might look like: <pre><code>public interface IPotion : IMajorRecord, IPotionGetter\n{\n// Major Record Fields\nFormKey FormKey { get; }\nstring? EditorID { get; set; }\n\n// Spell Fields\nstring? Name { get; set; }\nModel? Model { get; set; }\nstring? Icon { get; set; }\nIFormIDSetLink&lt;Script&gt; Script { get; }\n\n...\n}\n</code></pre></p> <p>And its corresponding Getter interface: <pre><code>public interface IPotionGetter : IMajorRecordGetter\n{\n// Major Record Fields\nFormKey FormKey { get; }\nstring? EditorID { get; }\n\n// Spell Fields\nstring? Name { get; }\nModel? Model { get; }\nstring? Icon { get; }\nIFormIDSetLinkGetter&lt;Script&gt; Script { get; }\n\n...\n}\n</code></pre></p> <p>These two interfaces that are generated for each record are pivotal touchstones of the entire library.  All functionality exposed will typically deal in one of these two types of interfaces, depending on whether the API requires/desires readonly functionality.</p> <p>Interfaces need implementing classes, so of course Mutagen offers straight classes for use as well: <pre><code>public class Potion : MajorRecord, IPotion\n{\n// Major Record Fields\nFormKey FormKey { get; }\nstring? EditorID { get; set; }\n\n// Spell Fields\nstring? Name { get; set; }\nModel? Model { get; set; }\nstring? Icon { get; set; }\nIFormIDSetLink&lt;Script&gt; Script { get; }\n\n...\n\npublic Potion(FormKey formKey)\n: base(formKey)\n{\n}\n\n...\n}\n</code></pre></p> <p>Of course, classes are also generated for the concepts of Mods themselves (<code>OblivionMod</code>, <code>SkyrimMod</code>), as well as subrecords (<code>Model</code>), Record Groups, etc.</p>"},{"location":"plugins/Interfaces-%28Aspect-Link-Getters%29/","title":"Interfaces","text":"<p>Mutagen exposes a few categories of interfaces: - Getters and Setters (Immutable vs Mutable) - Aspect (Expose aspects common to many records) - Link (Enables FormLinks to point to an umbrella of record types)</p>"},{"location":"plugins/Interfaces-%28Aspect-Link-Getters%29/#getters-and-setters","title":"Getters and Setters","text":"<p>Each autogenerated class also gets accompanying Getter/Setter interfaces</p> <pre><code>public class Potion : IPotion\n{\npublic int Value { get; set; }\npublic float Weight { get; set; }\npublic string Name { get; set; }\n}\n\npublic interface IPotionGetter\n{\nint Value { get; }\nfloat Weight { get; }\nstring Name { get; }\n}\n\npublic interface IPotion : IPotionGetter\n{\nint Value { get; set; }\nfloat Weight { get; set; }\nstring Name { get; set; }\n}\n</code></pre> <p>These are created mainly to expose objects in a readonly manner when appropriate. The Getter interfaces, specifically, are heavily used when reading data from a mod on-disk.</p>"},{"location":"plugins/Interfaces-%28Aspect-Link-Getters%29/#aspect-interfaces","title":"Aspect Interfaces","text":"<p>Aspect Interfaces expose common fields that are shared among many records.  They are used to help write code that is more generic and can process more than just a single record type.</p>"},{"location":"plugins/Interfaces-%28Aspect-Link-Getters%29/#problem-to-solve","title":"Problem to Solve","text":"<p><pre><code>public static void PrintName(Armor armor)\n{\nSystem.Console.WriteLine($\"Found armor with name: {armor.Name}\");\n}\n</code></pre> This works great!  For armors only. What if you wanted this function to work on any record that had <code>Name</code>?  What type do you specify as the parameter?</p> <p>This is where Aspect Interfaces come to the rescue. An interface is defined: <pre><code>public interface INamed\n{\nstring Name { get; set; }\n}\n</code></pre> This is an interface that any record that contains a <code>Name</code> can implement.  Now we can tweak our <code>PrintName</code> function to apply to any of these records, no matter what they are.</p>"},{"location":"plugins/Interfaces-%28Aspect-Link-Getters%29/#typical-usage","title":"Typical Usage","text":""},{"location":"plugins/Interfaces-%28Aspect-Link-Getters%29/#using-aspect-interfaces-as-a-parameter","title":"Using Aspect Interfaces as a Parameter","text":"<p>In the problem described above, a common use case is wanting to write a function that applies to multiple record types: <pre><code>public static void PrintName(INamedGetter namedRecord)\n{\nSystem.Console.WriteLine($\"Found name: {namedRecord.Name}\");\n}\n</code></pre> Using the Aspect Interface <code>INamed</code>, we have written a function that can apply to any record that has a name.  Could be an Armor, Npc, Weapon, etc.</p>"},{"location":"plugins/Interfaces-%28Aspect-Link-Getters%29/#weaving-multiple-aspect-interfaces-using-generics","title":"Weaving Multiple Aspect Interfaces Using Generics","text":"<p>The above example using one Aspect Interface as the parameter type is great if you're only interested in a single aspect.</p> <p>What if you wanted to write a function that could process any record that had a name, and had a model?  Well, then we need to combine multiple aspects.</p> <pre><code>public static void PrintNameAndModel&lt;TRecord&gt;(TRecord record)\nwhere TRecord : IMajorRecordCommon, INamed, IModeled\n{\nSystem.Console.WriteLine($\"{record.FormKey} with EditorID {record.EditorID} had name: {record.Name}.\");\nif (record.Model != null)\n{\nSystem.Console.WriteLine($\"   Model file: {record.Model.File}\");\n}\n}\n</code></pre> <p>This function uses C# Generics to specify that <code>TRecord</code> should be any record that is a Major Record, is named, and has a model.</p> <p>Now this function can directly access those aspects of records that are passed in.  Additionally, this function will automatically only accept records that have all these aspects.  A <code>Footstep</code> record, for example, which isn't named and doesn't have a model, would not be allowed to be passed to this function: C# would give a compiler error.</p>"},{"location":"plugins/Interfaces-%28Aspect-Link-Getters%29/#evolution","title":"Evolution","text":"<p>The list of Aspect Interfaces is an evolution.  Many more Aspect Interfaces could be created to expose fields that are common to many records.  If you see one that would be nice to add, please create an issue and ask for it to be added!  Over time, the list of Aspect Interfaces will be more and more complete.</p> <p>Additionally, Aspect Interfaces can be made to apply to cross-game records.  These of course will be more limited, as concepts that are shared across different games are less than those shared within the same game.</p>"},{"location":"plugins/Interfaces-%28Aspect-Link-Getters%29/#link-interfaces","title":"Link Interfaces","text":"<p>Link Interfaces have a different goal.  They act more as markers, rather than a vehicle to expose common fields.</p>"},{"location":"plugins/Interfaces-%28Aspect-Link-Getters%29/#problem-to-solve_1","title":"Problem to Solve","text":"<p>Mutagen's FormLinks can specify a record type that the FormKey they represent is allowed to match against.  It provides type safety to FormID/FormKey concepts.</p> <p>What happens when a FormLink should be able to point to multiple record types?  A container object can contain many different record types:  Armor, Weapons, etc.</p> <p>This is where Link Interfaces come into play.   A LinkInterface <code>IItem</code> is defined: <pre><code>public interface IItem\n{\n}\n</code></pre> Notice it doesn't have any fields.  It is just a marker that Armor, Weapons, etc can implement. Now FormLink can target that interface instead: <code>FormLink&lt;IItemGetter&gt;</code>.  This link can now point to any of those records that are marked with <code>IItem</code></p>"},{"location":"plugins/Interfaces-%28Aspect-Link-Getters%29/#typical-usage_1","title":"Typical Usage","text":""},{"location":"plugins/Interfaces-%28Aspect-Link-Getters%29/#knowing-types-allowed-into-a-formlink","title":"Knowing Types Allowed into a FormLink","text":"<p>Typical interaction with Link Interfaces are when users try to assign a record to a FormLink, and the compiler tells them it's not allowed.  They offer type safety, and block users from messing up and assigning a <code>Potion</code> to an Npc's <code>Race</code> field.</p> <p>However, you may want to know what types are allowed when you see a <code>FormLink&lt;IConstructibleGetter&gt;</code>.  There are two ways to get at this information:</p>"},{"location":"plugins/Interfaces-%28Aspect-Link-Getters%29/#visual-studio-intellisense","title":"Visual Studio Intellisense","text":"<p>Visual Studio offers a lot of tooling to be able to investigate classes/interfaces. Here is an example of <code>F12</code> being used to investigate <code>IConstructibleGetter</code> and see the comments on which objects implement it:</p> <p></p>"},{"location":"plugins/Interfaces-%28Aspect-Link-Getters%29/#autogenerated-documentation","title":"Autogenerated Documentation","text":"<p>A list of mappings also exists here on the wiki</p>"},{"location":"plugins/Interfaces-%28Aspect-Link-Getters%29/#evolution_1","title":"Evolution","text":"<p>New Link Interfaces are rarely defined.  These are usually known ahead of time and new ones aren't added.</p> <p>However, over time they can/could take on more of an Aspect Interface role, where common fields that are shared by all records implementing a Link Interface could be listed.  This would be Link Interfaces becoming more than just a simple marker, and becoming their own Aspect Interfaces of sorts.   If there are some fields common to all records of a Link Interface that you think should be exposed, please make an issue!</p>"},{"location":"plugins/Interfaces-%28Aspect-Link-Getters%29/#documentation","title":"Documentation","text":"<p>Mutagen autogenerates some documentation on what Aspect/Link interfaces exist, and what implements what.  You can find these in the Game Specific section of the Wiki.</p>"},{"location":"plugins/ModKey%2C-FormKey%2C-FormLink/","title":"ModKey, FormKey, FormLink","text":"<p>This article covers three fundamental identifiers: - ModKey (a unique identifier for a mod) - FormKey (FormID) - FormLink (Typing added to a FormKey)</p>"},{"location":"plugins/ModKey%2C-FormKey%2C-FormLink/#modkey","title":"ModKey","text":"<p><code>ModKey</code>s represent a unique identifier for a mod, as an alternative to a raw string.</p> <p>They contain: - <code>string</code> of a mod's name (without '.esp' or '.esm') - An <code>enum</code> of whether it is a master, plugin, or light master</p>"},{"location":"plugins/ModKey%2C-FormKey%2C-FormLink/#construction","title":"Construction","text":""},{"location":"plugins/ModKey%2C-FormKey%2C-FormLink/#basic-constructor","title":"Basic Constructor","text":"<pre><code>var modKey = new ModKey(\"Oblivion\", type: ModType.Master);\n</code></pre>"},{"location":"plugins/ModKey%2C-FormKey%2C-FormLink/#factory-construction","title":"Factory Construction","text":"<pre><code>if (ModKey.TryFromFileName(\"Oblivion.esm\", out var modKey))\n{\n// If conversion successful.\n}\nelse\n{\n// An unsuccessful conversion.\n// Might occur if there was an extension typo, like \"Oblivion.esz\"\n}\n\n// Would throw an exception if string could not be converted\nmodKey = ModKey.FromFileName(\"Skyrim.esm\");\n</code></pre>"},{"location":"plugins/ModKey%2C-FormKey%2C-FormLink/#formkey","title":"FormKey","text":"<p>A <code>FormKey</code> represents a unique identifier for a record. They are Mutagen's interpretation of a <code>FormID</code>.</p> <p>They contain: - A record's <code>uint</code> ID (without master indices) - A <code>ModKey</code></p> <p>A <code>FormKey</code> might be printed to a string as such: <code>123456:Oblivion.esm</code>.  The numbers are the last 6 digits of a FormID (with no mod index), followed by the string name of the mod it originated from. </p>"},{"location":"plugins/ModKey%2C-FormKey%2C-FormLink/#why-does-mutagen-use-formkeys-instead-of-formids","title":"Why does Mutagen use FormKeys instead of FormIDs?","text":""},{"location":"plugins/ModKey%2C-FormKey%2C-FormLink/#formkeys-avoid-master-mismatch-bugs","title":"FormKeys Avoid Master Mismatch Bugs","text":"<p><code>FormID</code> concepts are a staple of Bethesda modding, but they can be the source of some confusion and bugs.  This is usually due to the fact that a <code>FormID</code>'s master index bits are relative to the mod/loadorder that contains them.  This means a <code>FormID</code> contained in one mod can point to a completely different record if used to query into a different mod.  A user has to be very careful and \"correct\" the master indices to match the mod or context that they want to query into.</p> <p>Mutagen abstracts away some of the complexity of <code>FormID</code>s by exposing <code>FormKey</code> objects instead.  There are no Master Indices, but rather a string of the mod's name they originate from.  This means a <code>FormKey</code> can never be misinterpreted to point to the wrong record, no matter what context it is used in.</p>"},{"location":"plugins/ModKey%2C-FormKey%2C-FormLink/#formkeys-remove-the-255-mod-limit","title":"FormKeys Remove the 255 Mod Limit","text":"<p>As there is no Mod index stored as a byte within a <code>FormKey</code>, there is no 255 master limit within Mutagen.  Mods can contain records from &gt;255 number of masters, and <code>LoadOrders</code> can contain &gt;255 mods.</p> <p>However, note that the limit is still enforced when exporting to Binary;  When transposed to disk, there is no way around the 255 limit.</p>"},{"location":"plugins/ModKey%2C-FormKey%2C-FormLink/#construction_1","title":"Construction","text":""},{"location":"plugins/ModKey%2C-FormKey%2C-FormLink/#basic-constructor_1","title":"Basic Constructor","text":"<pre><code>var modKey = new ModKey(\"Oblivion\", type: ModType.Master);\nvar formKey = new FormKey(modKey, 0x123456);\n</code></pre>"},{"location":"plugins/ModKey%2C-FormKey%2C-FormLink/#try-factory","title":"Try Factory","text":"<pre><code>if (FormKey.TryFactory(\"123456:Oblivion.esm\", out var formKey))\n{\n// If conversion successful\n}\n\n// Would throw an exception if string could not be converted\nformKey = FormKey.Factory(\"123456:Skyrim.esm\");\n</code></pre>"},{"location":"plugins/ModKey%2C-FormKey%2C-FormLink/#formlink","title":"FormLink","text":"<p>A <code>FormLink</code> adds type safety to the concept of a <code>FormKey</code></p> <p>They contain: - A <code>FormKey</code> - A Major Record type <code>&lt;T&gt;</code></p> <p>As an example of the type safety they provide, consider an NPC's <code>Race</code> member, which is of type: <code>FormLink&lt;IRace&gt;</code>.  This link is not allowed to point to or link against any record that is not a <code>Race</code>.  It is hard to accidentally set a <code>FormLink&lt;IRace&gt;</code> link to point to an <code>IPotion</code> record, as attempting to do so would typically result in a compiler error.</p>"},{"location":"plugins/ModKey%2C-FormKey%2C-FormLink/#resolves","title":"Resolves","text":"<p>Combine a FormLink and a LinkCache to look up a record.  (The LinkCache is associated with a specific context like a load order or a single mod) <pre><code>var someItemLink = new FormLink&lt;IItemGetter&gt;(FormKey.Factory(\"123456:Skyrim.esm\"));\n\nif (someItemLink.TryResolve(myLinkCache, out var itemRecord))\n{\n// The FormKey associated with the FormLink was found\n// and was of the type associated with the link (IItemRecord)\nConsole.WriteLine($\"Was able to find the item record object: {itemRecord}\");\n}\n</code></pre></p>"},{"location":"plugins/ModKey%2C-FormKey%2C-FormLink/#scoping-a-resolve","title":"Scoping a Resolve","text":"<p>One important aspect is that Resolutions query based on the type.  So if the type is <code>Npc</code>, then only Npcs are parsed/inspected.  Some FormLinks have types that are too broad, though.  A <code>FormLink&lt;ISkyrimMajorRecordGetter&gt;</code> will inspect every record in the game, as it has no knowledge of what type to look for.  This may or may not be desired.</p> <p>For example, <code>IItemGetter</code> can be many different types of records (Ammunition, Armor, Books, etc).  If you know you only care about <code>Armor</code> records, you can further limit the scope: <pre><code>if (someItemLink.TryResolve&lt;IArmorGetter&gt;(myLinkCache, out var armorRecord))\n{\n// Found an Armor\n}\n</code></pre> This will block matching against anything that isn't an Armor, and also be much faster.</p>"},{"location":"plugins/ModKey%2C-FormKey%2C-FormLink/#setto","title":"SetTo","text":"<p>Generated records will have FormLinks that point to records.  You can change the record they point to by modifying the FormLink <pre><code>// Some Npc\nvar npc = new Npc(...);\n\n// Set to a new FormKey\nnpc.WornArmor.SetTo(FormKey.Factory(\"123456:Skyrim.esm\");\n\n// Or to an actual Armor record\nvar armor = new Armor(...);\nnpc.WornArmor.SetTo(armor);\n\n// Things that don't make sense will be blocked by the compiler\nvar ingredient = new Ingredient(...);\nnpc.WornArmor.SetTo(ingredient); // Compiler error\n</code></pre></p>"},{"location":"plugins/ModKey%2C-FormKey%2C-FormLink/#construction_2","title":"Construction","text":"<p>Most FormLinks come as part of generated record objects, but you can also create your own. Note that usually FormLinks work best when they point to getter interfaces, rather than setters. <pre><code>// A FormKey without a type\nFormKey myArmorKey = FormKey.Factory(\"123456:Skyrim.esm\");\n\n// An actual Armor object\nIArmorGetter armor = new Armor(myArmorKey);\n\n// Time to make some FormLinks\n// Can create by passing in the FormKey or record object\nFormLink&lt;IArmorGetter&gt; myArmorLink = new FormLink&lt;IArmorGetter&gt;(myArmorKey);\nmyArmorLink = new FormLink&lt;IArmorGetter&gt;(armor);\n\n// They also have implicit operators if the left hand side's type is known\nmyArmorLink = myArmorKey;\nmyArmorLink = armor;\n\n// FormKeys and record objects have AsLink helpers, too, when the left hand side type isn't known\nvar myOtherLink = myArmorKey.AsLink&lt;IArmorGetter&gt;();\nvar myOtherLink2 = armor.AsLink&lt;IArmorGetter&gt;();\n</code></pre></p>"},{"location":"plugins/Printing/","title":"Printing","text":"<p>(Latest version of Mutagen does not match these docs.  Will soon be updated to match this documentation)</p>"},{"location":"plugins/Printing/#normal-tostring","title":"Normal ToString","text":"<p>If you call <code>ToString()</code> on a Mutagen object, you will typically not see any content within the string.  You will usually get just the class name, or some short but informative identifying string, such as Major Records returning their FormKey:</p> <p><code>Skyrim.Npc 123456:Skyrim.esm</code></p>"},{"location":"plugins/Printing/#iprintable-and-structuredstringbuilder","title":"IPrintable and StructuredStringBuilder","text":"<p>All Mutagen objects implement <code>IPrintable</code>, which exposes a <code>Print()</code> method.  Calling this will do a more verbose printing of the content: <pre><code>var str = npc.Print();\n</code></pre></p>"},{"location":"plugins/Translation-Masks/","title":"Translation Masks","text":"<p>Several functionalities such as Equality, DeepCopy, and a few others have support for a concept called Translation Masks.  These allow for customization of what members are involved in those operations.</p>"},{"location":"plugins/Translation-Masks/#equality","title":"Equality","text":"<p>Providing a translation mask to an Equality call will control what members are compared when determining equality.</p> <pre><code>var mask = new Npc.TranslationMask(defaultOn: false)\n{\nHeight = true,\nWeight = true,\n};\n\nnpc.Equals(npc2, mask);\n</code></pre> <p>The above would compare equality of the Height and Weight of the two Npcs.  All other members would not be considered.</p>"},{"location":"plugins/Translation-Masks/#deepcopyin","title":"DeepCopy(In)","text":"<pre><code>var mask = new Npc.TranslationMask(defaultOn: false)\n{\nHeight = true,\nWeight = true,\nDestructible = true,\n};\n\nnpc.DeepCopyIn(npc2, mask);\n</code></pre> <p>The above would copy in the values of the <code>Height</code>, <code>Weight</code>, and <code>Destructible</code> subobject from <code>npc2</code> into <code>npc</code>.  All other members of <code>npc</code> would be left untouched.</p>"},{"location":"plugins/Translation-Masks/#translation-mask-construction","title":"Translation Mask Construction","text":"<p>The above examples are very simple mask constructions.  They can get more complex when there are subobjects and/or lists involved.</p>"},{"location":"plugins/Translation-Masks/#defaulton-parameter","title":"defaultOn Parameter","text":"<p>When creating a mask, you can either give it <code>defaultOn: true</code> where all the fields will be marked <code>true</code> by default, and then you can selectively mark fields false as desired.  Inversely, you can give it <code>defaultOn: false</code> where all the fields will be marked <code>false</code> by default, and you'll need to turn specific fields <code>true</code> as needed.</p> <p>Copy of only one field: <pre><code>// Only copy Height\nvar mask = new Npc.TranslationMask(defaultOn: false)\n{\nHeight = true,\n};\n</code></pre></p> <p>Copy of all but one field: <pre><code>// Copy everything BUT Height\nvar mask = new Npc.TranslationMask(defaultOn: true)\n{\nHeight = false,\n};\n</code></pre></p>"},{"location":"plugins/Translation-Masks/#subobjects","title":"Subobjects","text":"<p>When a record has subobjects, the subobject field is itself a Translation mask letting you set members within that subobject <pre><code>// Copy destructible subobject, but not its Stages field\nvar mask = new Npc.TranslationMask(defaultOn: true)\n{\nDestructible = new Destructible.TranslationMask(true)\n{\nStages = false\n}\n};\n</code></pre></p>"},{"location":"plugins/Translation-Masks/#onoverall-parameter","title":"onOverall Parameter","text":"<p>This one has a lot more nuance.  It relates to behavior for a nullable subobject, and gives the user more control as to how those are handled.</p> <p>It does not have any effect if it is the top level mask.   It only has an effect if it's a submask used within another mask.</p> <p>To help demonstrate its usage, let's take Skyrim Npc as a case study.  It has a simplified interface of: <pre><code>public interface INpc\n{\n// A name\nstring? Name { get; set; }\n// A nullable subobject\nDestructible? Destructible { get; set; }\n// Other fields\n}\n</code></pre></p> <p>Consider this: <pre><code>rec.DeepCopy(new Npc.TranslationMask(true)\n{\nName = false,\n// Implicit:\n// Destructible = null\n});\n</code></pre> This is an easy way to specify that you want all fields copied except the name.  Destructible's submask object will be left null, but in this case, that means we want to copy it.  (we shouldn't have to define Destructible's subobject in order to bring it over)</p> <p>Okay, but what about the case when we want to omit Destructible, then?  There's some confusion when you try to do this with nullable subobjects.  Does a false mean: - Destructible should not be considered at all during equality - All fields on the destructible mask should be false. Those are two slightly different things.</p> <p>The bool <code>onOverall</code> gives us the extra control to specify exactly what we want.</p> <p><pre><code>// This will skip Destructible from being considered during the copy altogether\nrec.DeepCopy(new Npc.TranslationMask(true)\n{\nName = false,\nDestructible = new Destructible.TranslationMask(doesNotMatter, onOverall: false)\n});\n</code></pre> So whatever value the <code>rec.Destructible</code> had before, it will still have, as it will be not touched or considered at all.</p> <p>This is in contrast to this: <pre><code>rec.DeepCopy(new Npc.TranslationMask(true)\n{\nName = false,\nDestructible = new Destructible.TranslationMask(\ndefaultOn: false, // optional, but shown for clarity\nonOverall: true)\n{\nStages = true\n}\n});\n</code></pre> This setup has <code>onOverall</code> of true, and so the mask will be applied and considered during the copy. <code>defaultOn</code> is false, and so by default it would only copy over the <code>Stages</code> member of Destructible, as well as respecting the nullability.  If the source Npc had a null Destructible, the the target will get a null Destructible.</p> <p>As you can see, <code>defaultOn = false</code> still means the mask has effects during the copy job.  <code>onOverall = false</code> is what we'd set if we did not want it to have any effects, and wanted <code>Destructible</code> to not be considered whatsoever.</p>"},{"location":"plugins/Translation-Masks/#subobject-shorthand","title":"Subobject Shorthand","text":"<p>When dealing with subobjects, the above API can get a bit verbose.  For the basic situations of inclusion/exclusion, Translation Masks are implicitly convertible from <code>bool</code>s.  So you can do something like this:</p> <pre><code>rec.DeepCopy(new Npc.TranslationMask(true)\n{\n// Boolean converts to a translation mask for you\nDestructible = false\n// Equivalent to\n// Destructible = new Destructible.TranslationMask(false, false)\n});\n</code></pre> <p>This would copy over everything but the <code>Destructible</code> member, but is much easier to write.  Similarly, you can just provide <code>true</code> to include it in a false-by-default mask.</p>"},{"location":"plugins/Translation-Masks/#best-practices","title":"Best Practices","text":""},{"location":"plugins/Translation-Masks/#create-once-use-many","title":"Create Once, Use Many","text":"<p>It's best practice to not create a translation mask per call.  As in, try to not make a new mask for every equality call, but rather make the desired mask once ahead of time and reuse it for each equality call if possible.</p>"},{"location":"plugins/Typical-Mod-Construction-and-Importing/","title":"Typical Mod Construction and Importing","text":"<p>If you're only dealing with one game, then code like this is typical: <pre><code>public void SomeFunction()\n{\nvar newMod = new SkyrimMod(ModKey.FromFileName(\"MyMod.esp\"), SkyrimRelease.SkyrimSE);\n\nvar mutableInputMod = SkyrimMod.CreateFromBinary(inputPath, SkyrimRelease.SkyrimSE);\n\nusing var readOnlyInputMod = SkyrimMod.CreateFromBinaryOverlay(inputPath, SkyrimRelease.SkyrimSE);\n}\n</code></pre></p>"},{"location":"plugins/Typical-Mod-Construction-and-Importing/#generic-variants","title":"Generic Variants","text":"<p>If you're intending to work on many game types in generic code, then the above code won't work well.  Instead, it looks like: <pre><code>public void SomeFunction&lt;TMod&gt;(GameRelease release, ModPath inputPath)\nwhere TMod : IModGetter\n{\nvar newMod = ModInstantiator&lt;TMod&gt;.Activator(ModKey.FromFileName(\"MyMod.esp\"), release);\n\nvar importedMod = ModInstantiator&lt;TMod&gt;.Importer(inputPath, release);\n}\n</code></pre> In this way, this function does not need to know whether it's a SkyrimMod, or a Fallout4Mod.  This of course, comes with the downside of only being able to interact with the object as much as the TMod constraint allows.  You would not be able to access the Water group, for example, as it's uncertain if the mod in question has those.</p>"},{"location":"plugins/Typical-Mod-Construction-and-Importing/#getter-vs-setter","title":"Getter vs Setter","text":"<p>If the constraint <code>TMod</code> is only a Getter interface, then <code>ModInstantiator&lt;TMod&gt;.Importer</code> will return a binary overlay underlying object.  If it's a setter constraint, then it must be backed by a fully imported mutable object.</p>"},{"location":"strings/Translated-Strings/","title":"Translated Strings","text":"<p>Newer Bethesda titles come with the ability for a single string record to have multiple different translations in different languages.  This is provided via the concept of extra <code>.strings</code> files, which provide an index to string mapping to alternate translations for a language.  On the mod file binary side, string record contents are replaced with an index that can be used to lookup a value in the strings files for the language desired.</p>"},{"location":"strings/Translated-Strings/#translatedstring","title":"TranslatedString","text":"<p>Mutagen exposes this functionality via the <code>TranslatedString</code> class.  It can be used almost as a string, with its basic get/set accessor.  This will get/set the for language <code>TranslatedString.DefaultLanguage</code>, which is by default set to English.</p> <pre><code>Npc npc = ...;\nSystem.Console.WriteLine($\"English name: {npc.Name}\");\nnpc.Name = \"New English Name\";\n</code></pre>"},{"location":"strings/Translated-Strings/#multi-language-support","title":"Multi-Language Support","text":"<p><code>TranslatedString</code> also acts as a language dictionary in more advanced usage, allowing access to the alternate strings. <pre><code>Npc npc = ...;\nif (npc.Name.TryLookup(Language.French, out var frenchString))\n{\nSystem.Console.WriteLine($\"French name: {frenchString}\");\n}\n\nnpc.Name.Set(Language.French, \"Lutin\");\n</code></pre></p>"},{"location":"strings/Translated-Strings/#data-loading-patterns","title":"Data Loading Patterns","text":"<p><code>TranslatedString</code> queries and loads data in a lazy fashion.  Strings files for any given language will not be loaded until they are asked for.   Loose strings file located for per language will be used if present, otherwise BSAs will be searched for the applicable strings language file. </p> <p>All operations are threadsafe for <code>TranslatedString</code>.</p>"},{"location":"strings/Translated-Strings/#internals","title":"Internals","text":""},{"location":"strings/Translated-Strings/#stringslookupoverlay","title":"StringsLookupOverlay","text":"<p>This class lightly wraps the data from a single strings file, indexing the available string keys but doing no parsing on the strings themselves.  The raw string byte data is cached internally for easy random access.  Strings are parsed from the raw data on lookup, and the results not cached. All operations on <code>StringsLookupOverlay</code> are threadsafe. <pre><code>var stringsOverlay = new StringsLookupOverlay(pathToStringsFile);\nuint key = 1234;\nif (stringsOverlay.TryLookup(key, out var containedString))\n{\nSystem.Console.WriteLine($\"{pathToStringsFile} contained {key}: {containedString}\");\n}\n</code></pre></p>"},{"location":"strings/Translated-Strings/#stringsfolderlookupoverlay","title":"StringsFolderLookupOverlay","text":"<p>This class overlays on top an entire data folder, allowing lazy access to all strings files within, both loose and inside BSA files.  Internal StringLookupOverlays will be created and cached when required to serve a query.  Loose strings files for a query will have priority, followed by the first applicable strings files found in the BSAs.  All operations on <code>StringsFolderLookupOverlay</code> are threadsafe.</p> <pre><code>ModKey modKey = ...;\nuint key = 1234;\nLanguage language = Language.English;\nStringsSource source = StringsSource.DL;\n\nvar stringsFolderOverlay = StringsFolderLookupOverlay.TypicalFactory(pathToDataFolder);\nif (stringsFolderOverlay.TryLookup(source, language, modKey, key, out var containedString))\n{\nSystem.Console.WriteLine($\"{source} {language} contained {key}: {containedString}\");\n}\n</code></pre>"},{"location":"strings/Translated-Strings/#stringswriter","title":"StringsWriter","text":"<p>A class for exporting strings of various languages into the appropriate strings files.  This currently only supports export into Loose Files, not into a packed BSA.  A <code>StringsWriter</code> can be loaded with strings, and then exports to disk when disposed. <pre><code>ModKey modKey = ...;\nStringsSource source = StringsSource.DL;\nTranslatedString myStr = new TranslatedString();\nmyStr.String = \"Goblin\";\nmyStr.Set(Language.French, \"Lutin\");\n\nusing (var stringsWriter = new StringsWriter(modKey, pathToStringsFolder))\n{\nuint key = stringsWriter.Register(myStr, source);\nSystem.Console.WriteLine($\"{myStr} was registered into the strings files for {source} under key: {key}.\");\n}\n</code></pre></p>"},{"location":"top/Archives/","title":"Archives (BSAs)","text":"<p>Certain Bethesda files like textures, meshes, and similar assets are often stored in zipped up files with extensions like <code>.bsa</code> or <code>b2a</code>.</p> <p>Mutagen calls these <code>Archives</code> and offers API to read the contents from those.   Writing new Archives is not something Mutagen can currently do, but is on the list of features to eventually be added.</p>"},{"location":"top/Archives/#reading","title":"Reading","text":""},{"location":"top/Archives/#archive-reader","title":"Archive Reader","text":"<p>To start reading an Archive, you must make an Archive Reader: <pre><code>var reader = Archive.CreateReader(GameRelease.SkyrimSE, somePathToBSA);\n</code></pre></p>"},{"location":"top/Archives/#file-enumeration","title":"File Enumeration","text":"<p>With an Archive Reader, you can enumerate all the files it contains: <pre><code>foreach (var file in reader.Files)\n{\nConsole.WriteLine($\"File at {file.Path}, with size {file.Size}\");\n\nvar fileBytes = file.GetBytes();\n// You can also get the file data by stream\n}\n</code></pre></p>"},{"location":"top/Archives/#folder-lookup","title":"Folder Lookup","text":"<p>Archive Readers can also look up specific folders: <pre><code>if (reader.TryGetFolder(\"some/sub/folder\", out var archiveFolder))\n{\n// Found the folder inside the archive\n}\n</code></pre></p> <p>Folders have similar API of looping contained files as an Archive Reader</p>"},{"location":"top/Archives/#finding-applicable-archives","title":"Finding Applicable Archives","text":"<p>(Todo)</p>"},{"location":"top/Big-Cheat-Sheet/","title":"Big Cheat Sheet","text":""},{"location":"top/Big-Cheat-Sheet/#overview","title":"Overview","text":"<p>A massive list of code snippets without much contextual explaination.</p>"},{"location":"top/Big-Cheat-Sheet/#related-reading","title":"Related Reading","text":"<p>Relevant wikis for more detailed reading will be linked.</p>"},{"location":"top/Big-Cheat-Sheet/#target-game","title":"Target Game","text":"<p>Most code snippets will assume Skyrim SE, but code should work for any game, generally.</p>"},{"location":"top/Big-Cheat-Sheet/#preparing-the-examples","title":"Preparing the Examples","text":"<p>When <code>...</code> is seen, that generally means the example will not cover how that object might have been made.  <code>...</code> is not actually valid code to be copied and pasted.</p>"},{"location":"top/Big-Cheat-Sheet/#missing-namespaces","title":"Missing Namespaces","text":"<p>If you're just copy pasting code, often it will not compile because some required namespaces are missing.  You can have the IDE import them by clicking on the red object in question and activating quick fixes (<code>Ctrl - .</code> in Visual Studio).</p> <p>More Reading</p>"},{"location":"top/Big-Cheat-Sheet/#construct-an-environment","title":"Construct an Environment","text":"<pre><code>using var env = GameEnvironment.Typical.Skyrim(SkyrimRelease.SkyrimSE);\n\nConsole.WriteLine($\"Data folder is: {state.DataFolderPath}\");\nConsole.WriteLine($\"Load order is:\");\nforeach (var listing in state.LoadOrder.ListedOrder)\n{\nConsole.WriteLine($\"  {listing}\");\n}\n</code></pre> <p>Read About Environments</p>"},{"location":"top/Big-Cheat-Sheet/#retrieve-a-mod-from-a-load-order","title":"Retrieve a Mod From a Load Order","text":"<p><pre><code>var mod = myLoadOrder[\"MyMod.esp\"];\n</code></pre> or TryGet alternative <pre><code>if (myLoadOrder.TryGetValue(\"MyMod.esp\", out var mod))\n{\n// ..\n}\n</code></pre></p> <p>Read About Mod Retrieval</p>"},{"location":"top/Big-Cheat-Sheet/#construct-a-modkey","title":"Construct a ModKey","text":"<p><pre><code>var modKey = ModKey.FromFileName(\"Skyrim.esm\");\nmodKey = new ModKey(\"Skyrim\", ModType.Plugin);\n</code></pre> Read About ModKeys</p>"},{"location":"top/Big-Cheat-Sheet/#get-list-of-masters-from-a-mod","title":"Get List of Masters From A Mod","text":""},{"location":"top/Big-Cheat-Sheet/#via-masterreferencecollection","title":"Via MasterReferenceCollection","text":"<pre><code>var masterCollection = MasterReferenceCollection.FromPath(pathToMod, GameRelease.SkyrimSE);\n\nConsole.WriteLine($\"The mod {masterCollection.CurrentMod} has masters:\");\nforeach (var master in masterCollection.Masters)\n{\nConsole.WriteLine($\"  {master.Master.FileName}\");\n}\n</code></pre>"},{"location":"top/Big-Cheat-Sheet/#via-mod-object","title":"Via Mod Object","text":"<pre><code>using var mod = SkyrimMod.CreateFromBinaryOverlay(pathToMod, SkyrimRelease.SkyrimSE);\n\nConsole.WriteLine($\"The mod {mod.ModKey} has masters:\");\nforeach (var master in mod.ModHeader.MasterReferences)\n{\nConsole.WriteLine($\"  {master.Master.FileName}\");\n}\n</code></pre>"},{"location":"top/Big-Cheat-Sheet/#get-access-to-record-data","title":"Get Access to Record Data","text":"<p>If you don't know what records you want to process, and just want to process everything the load order has, then this is typical: <pre><code>foreach (var formList in loadOrder.PriorityOrder.FormList.WinningOverrides())\n{\n    // each form list that exists, do something\n}\n</code></pre> If you know ahead of time the ones you want to look for and process, then it's more typical to do this:</p> <p><pre><code>if (state.LinkCache.TryResolve&lt;IFormListGetter&gt;(FormKey.Factory(\"123456:Skyrim.esm\"), out var foundRecord))\n{\n    // Found the specific record we were looking for\n}\n</code></pre> Using the FormKey Generator project output is better than hand writing, in this case.</p>"},{"location":"top/Big-Cheat-Sheet/#convert-formkey-to-formid","title":"Convert FormKey to FormID","text":""},{"location":"top/Big-Cheat-Sheet/#via-masterreferencecollection_1","title":"Via MasterReferenceCollection","text":"<pre><code>FormKey formKey = ...;\nIMasterReferenceCollection masterCollection = ...;\n\nFormID formID = masterCollection.GetFormID(formKey);\n</code></pre> <p>Read About FormKeys</p>"},{"location":"top/Big-Cheat-Sheet/#convert-formkey-to-formlink","title":"Convert FormKey to FormLink","text":"<pre><code>FormKey formKey = ...;\n// NOTE: Typically want to use the \"getter\" interfaces for FormLinks\nvar npcLink = formKey.ToLink&lt;INpcGetter&gt;();\n</code></pre> <p>Read About FormKeys</p>"},{"location":"top/Big-Cheat-Sheet/#convert-majorrecord-to-formlink","title":"Convert MajorRecord to FormLink","text":"<pre><code>INpcGetter npcGetter = ...;\nvar npcLink = npcGetter.ToLink();\n\n// If the source major record type is not a getter interface\n// it is recommended to take extra steps to keep the link targeting the getter interface\nINpc npcSetter = ...;\nvar npcLink2 = npcSetter.ToLink&lt;INpcGetter&gt;();\n// or\nIFormLinkGetter&lt;INpcGetter&gt; npcLink3 = npcSetter.ToLink();\n</code></pre>"},{"location":"top/Big-Cheat-Sheet/#iterate-winning-overrides","title":"Iterate Winning Overrides","text":"<pre><code>// Load order is typically retrieved via Synthesis state or Environment systems\nforeach (var keywordGetter in loadOrder.PriorityOrder.Keywords().WinningOverrides())\n{\n// Process each keyword record's winning override\n}\n</code></pre>"},{"location":"top/Big-Cheat-Sheet/#iterate-records-original-definitions","title":"Iterate Records' Original Definitions","text":"<pre><code>// By swapping to ListedOrder, the loop will now iterate over the original definitions of each record\n// By viewing the load order \"backwards\", is sees the original mods as the winning override to return\nforeach (var keywordGetter in loadOrder.ListedOrder.Keywords().WinningOverrides())\n{\n// Process each keyword record's original definition\n}\n</code></pre>"},{"location":"top/Big-Cheat-Sheet/#check-if-a-formlink-points-to-a-specific-record","title":"Check If A FormLink Points to a Specific Record","text":""},{"location":"top/Big-Cheat-Sheet/#by-formkey","title":"By FormKey","text":"<pre><code>INpcGetter npc = ...;\nvar target = FormKey.Factory(\"013745:Skyrim.esm\"); // Khajiit Race\nif (target.FormKey.Equals(npc.Race))\n{\n}\n</code></pre> <p>Read About FormKeys</p>"},{"location":"top/Big-Cheat-Sheet/#by-formlink","title":"By FormLink","text":"<pre><code>INpcGetter npc = ...;\nvar targetFormLink = FormKey\n.Factory(\"013745:Skyrim.esm\") // Khajiit Race\n.AsLink&lt;IRaceGetter&gt;(); // Convert to a FormLink for more type safety\nif (target.Equals(npc.Race))\n{\n}\n</code></pre> <p>Read About FormLinks</p>"},{"location":"top/Big-Cheat-Sheet/#using-formkey-mapping-library","title":"Using FormKey Mapping Library","text":"<pre><code>INpcGetter npc = ...;\nif (Skyrim.Race.KhajiitRace.Equals(npc.Race))\n{\n}\n</code></pre> <p>Read About FormLink Mapping</p>"},{"location":"top/Big-Cheat-Sheet/#duplicate-a-record","title":"Duplicate a Record","text":"<p>Copy an existing record with a new FormKey <pre><code>var dup = someRecord.Duplicate(newFormKey);\n</code></pre> <pre><code>// Assign the next available FormKey the mod has\nvar dup = someMod.Npcs.DuplicateInAsNewRecord();\n// Assign a specific FormKey\nvar dup2 = someMod.Npcs.DuplicateInAsNewRecord(newFormKey);\n// Hook into the FormID persistence system\nvar dup3 = someMod.Npcs.DuplicateInAsNewRecord(someEditorId);\n</code></pre></p> <p>Read more about duplication Read more about FormKey Persistence</p>"},{"location":"top/Correctness/","title":"Correctness","text":""},{"location":"top/Correctness/#passthrough-testing","title":"Passthrough Testing","text":"<p>Besides general unit tests for edge-case prone code section, Mutagen has a passthrough test suite that it uses to help confirm correctness.  </p>"},{"location":"top/Correctness/#definition","title":"Definition","text":"<p>A passthrough means that Mutagen will read in a source file into the classes it provides, and then immediately re-export.  If the two files match, then it was able to \"pass through\" Mutagen's systems without being changed unexpectedly.</p>"},{"location":"top/Correctness/#pre-processing","title":"Pre-Processing","text":"<p>There is a bit more that goes into a passthrough than just importing, re-exporting, and comparing, though.  For one, it is much easier to compare files match byte to byte if you're comparing the uncompressed data.  As such, there are a few pre-processing steps that happen before a passthrough test is actually executed.</p>"},{"location":"top/Correctness/#decompression","title":"Decompression","text":"<p>The source file is lightly processed so that all the records are in their decompressed format.</p>"},{"location":"top/Correctness/#float-standardization","title":"Float Standardization","text":"<p>Some float values can be stored in multiple ways.  A common one is zero, which is stored as zero by Bethesda in two different formats.  This stage standardizes floats to be the format Mutagen will export as, while leaving their actual represented values intact.</p>"},{"location":"top/Correctness/#subrecord-order-standardization","title":"Subrecord Order Standardization","text":"<p>Subrecords usually come in a predictable order, but they are not required to.  Bethesda in some circumstances will deviate and shuffle the subrecords to where the content overall stays the same, but the order they show up on disk is different.  This phase moves the subrecords to be in the order Mutagen would export them in.  This helps the byte to byte comparison line up better without being distracted by subrecords of differing order.</p>"},{"location":"top/Correctness/#strings-file-key-reindexing","title":"Strings File Key Reindexing","text":"<p>Mutagen does not retain strings file key indexes compared to the original.  This is not important information to store and persist so that it matches the input.  As such, the source file needs to be reindexed so that it matches what Mutagen will output.  This just means making the key index start at 1 and increment for every string that was exported.</p>"},{"location":"top/Correctness/#other-minor-inconsistencies","title":"Other Minor Inconsistencies","text":"<p>There are a few other cases of inconsistencies that need to be aligned, similar to the ones above.</p>"},{"location":"top/Correctness/#running","title":"Running","text":"<p>Once a preprocessed file that has been trimmed, aligned, and decompressed is ready, then the actual passthrough will be done.  Mutagen will import the original (unprocessed) file, and re-export it.  The result will be compared to the pre-processed file which then should match byte to byte.  If there is even one byte differing, the passthrough fails, and either Mutagen's code must be fixed, or if it was just a non-important inconsistency as described above, the passthrough systems will be adjusted to compensate.</p>"},{"location":"top/Correctness/#helper-ui","title":"Helper UI","text":"<p>There is an internal helper UI to to facilitate selecting which tests to run, as well as digesting the parallel output that results.</p> <p></p> <p></p>"},{"location":"top/Correctness/#more-references","title":"More References","text":"<p>More documentation to come, but in the meantime, there is some testing information in this video about Record Generation.</p>"},{"location":"top/Json/","title":"Json","text":"<p>Currently, the libraries that Mutagen offers related to Json targets <code>Newtonsoft.Json</code>.  Alternatives can be added for <code>System.Text.Json</code> if there's demand.</p>"},{"location":"top/Json/#json-converters","title":"Json Converters","text":"<p>There are some built in converters to allow for FormKeys/FormLinks/ModKeys to be included in a Json DTO.</p> <p><pre><code>public class MyDto\n{\npublic FormKey MyFormKey { get; set; }\npublic IFormLinkGetter&lt;IArmorGetter&gt; MyArmorLink { get; set; } = FormLink&lt;IArmorGetter&gt;.Null;\npublic IFormLinkIdentifier MyRuntimeLink { get; set; } = FormLink&lt;IMajorRecordGetter&gt;.Null;\npublic ModKey MyModKey { get; set; }\n}\n\n// ..\n\nvar settings = new JsonSerializerSettings();\n// Convenience function to add all converters\nsettings.AddMutagenConverters();\n\nvar someDto = new MyDto()\n{\nMyFormKey = FormKey.Factory(\"123456:MyMod.esp\"),\nMyArmorLink = FormKey.Factory(\"000123:MyMod.esp\").ToLink&lt;IArmorGetter&gt;(),\nMyRuntimeLink = new FormLinkInformation(FormKey.Factory(\"000456:MyMod.esp\"), typeof(IWeaponGetter)),\nMyModKey = \"MyMod.esp\",\n};\n\nvar str = JsonConvert.SerializeObject(someDto);\nConsole.WriteLine(str);\n</code></pre> Prints <pre><code>{\n  \"MyFormKey\": \"123456:MyMod.esp\",\n  \"MyArmorLink\": \"000123:MyMod.esp\",\n  \"MyRuntimeLink\": \"000456:MyMod.esp&lt;Skyrim.Weapon&gt;\",\n  \"MyModKey \": \"MyMod.esp\"\n}\n</code></pre></p>"},{"location":"wpf/","title":"WPF Library","text":"<p>If you are making a C# WPF UI application with Mutagen, you can import <code>Mutagen.Bethesda.WPF</code> to get some tooling related to Bethesda specific content. - Controls for Bethesda specific concepts, such as FormKeyPickers, LoadOrder displays, etc - Reflection powered settings editor - ValueConverters for binding things like Visibility to whether a FormKey can be looked up</p> <p>The Mutagen repository has a Test Display WPF app, which flexes a lot of these controls, and can be a good tutorial for how to use them.</p> <p>Explore the right hand side bar for more specifics on the features provided by Mutagen's WPF library</p>"},{"location":"wpf/#formkey-pickers","title":"FormKey Pickers","text":""},{"location":"wpf/#modkey-pickers","title":"ModKey Pickers","text":""},{"location":"wpf/#reflection-powered-settings","title":"Reflection Powered Settings","text":""},{"location":"wpf/Adding-Required-Resources/","title":"Adding Required Resources","text":"<p><code>Mutagen.WPF</code> is built with style-less controls.  This means the controls are just logic, and you can add your own look exactly how you want it.</p> <p>Typically though a default look is provided, and <code>Mutagen.WPF</code> does this as well.  It is built on top of MahApps, and other reusable libraries.  </p>"},{"location":"wpf/Adding-Required-Resources/#global-import","title":"Global Import","text":"<p>To import these resources/looks, the easiest way is to modify the <code>App.xaml</code> file that comes with every WPF project: <pre><code>&lt;Application ...&gt;\n&lt;Application.Resources&gt;\n&lt;ResourceDictionary&gt;\n&lt;ResourceDictionary.MergedDictionaries&gt;\n&lt;!--  MahApps.Metro resource dictionaries.  --&gt;\n&lt;ResourceDictionary Source=\"pack://application:,,,/MahApps.Metro;component/Styles/Controls.xaml\" /&gt;\n&lt;ResourceDictionary Source=\"pack://application:,,,/MahApps.Metro;component/Styles/Fonts.xaml\" /&gt;\n&lt;ResourceDictionary Source=\"pack://application:,,,/MahApps.Metro;component/Styles/Controls.Buttons.xaml\" /&gt;\n\n&lt;!--  Purple Accent and AppTheme setting  --&gt;\n&lt;ResourceDictionary Source=\"pack://application:,,,/MahApps.Metro;component/Styles/Themes/Dark.Purple.xaml\" /&gt;\n\n&lt;!--  Noggog.WPF Theming  --&gt;\n&lt;ResourceDictionary Source=\"pack://application:,,,/Noggog.WPF;component/Everything.xaml\" /&gt;\n\n&lt;!--  Mutagen Specific Theming  --&gt;\n&lt;ResourceDictionary Source=\"pack://application:,,,/Mutagen.Bethesda.WPF;component/Everything.xaml\" /&gt;\n\n&lt;/ResourceDictionary.MergedDictionaries&gt;\n&lt;/ResourceDictionary&gt;\n&lt;/Application.Resources&gt;\n&lt;/Application&gt;\n</code></pre></p>"},{"location":"wpf/Adding-Required-Resources/#non-global-import","title":"Non-Global Import","text":"<p>You can also add the above ResourceDictionary to specific controls in your WPF app, if you don't want to import/apply them globally to everything.</p>"},{"location":"wpf/Adding-Required-Resources/#work-in-progress","title":"Work In Progress","text":"<p>These patterns may be adjusted over time, as they don't allow for the easiest customization of color theming and such.  As better patterns for exposing more control are discovered, these suggestions might change.</p>"},{"location":"wpf/FormKey-Picker/","title":"FormKey Picker","text":"<p>The FormKey Picker helps users select record(s) by typing in: - EditorIDs - FormKeys - FormIDs (Mod indices relative to current load order)</p> <p>The picker can reference a LinkCache to do lookups to help display and locate records that actually exist in the user's active load order.</p> <p>They can also be scoped to only allow or search for specific record types, if desired.</p> <p>Make sure you've added the Required Resources, or the controls will not have any display.</p> <p>The Mutagen Test Display app utilizes the FormKey pickers, and provides a good example of how to use them from within a WPF app.</p>"},{"location":"wpf/FormKey-Picker/#formkey-picker_1","title":"FormKey Picker","text":"<p>This is a picker to select a single FormKey.</p> <p></p>"},{"location":"wpf/FormKey-Picker/#view-side","title":"View Side","text":"<pre><code>&lt;UserControl\n...\nxmlns:plugins=\"clr-namespace:Mutagen.Bethesda.WPF.Plugins;assembly=Mutagen.Bethesda.WPF\" &gt;\n&lt;plugins:FormKeyPicker FormKey=\"{Binding MyFormKey}\"\nLinkCache=\"{Binding MyLinkCache}\"\nScopedTypes=\"{Binding MyDesiredTypes}\" /&gt;\n&lt;/UserControl&gt;\n</code></pre>"},{"location":"wpf/FormKey-Picker/#viewmodel-side","title":"ViewModel Side","text":"<pre><code>// Some mechanics shown here are from `ReactiveUI`, or `Noggog.WPF`\npublic class MyViewModel : ViewModel\n{\n[Reactive]\npublic FormKey MyFormKey { get; set; }\n\npublic ILinkCache MyLinkCache { get; }\n\npublic IEnumerable&lt;Type&gt; MyDesiredTypes { get; }\n\npublic MyViewModel()\n{\n// Create a GameEnvironment, to get a LinkCache connected to the current users' setup\nvar env = GameEnvironment.Typical.Skyrim(\nSkyrimRelease.SkyrimSE, // By passing in this preference, we only cache FormKey/EditorID info, keeping memory usage down\nLinkCachePreferences.OnlyIdentifiers());\n\n// When the ViewModel is destroyed, clean up the environment object.  Good practice\nenv.DisposeWith(this);\n\n// Set the ViewModel's LinkCache to the one given by the environment\nLinkCache = env.LinkCache;\n\n// We only care about Armor records\nScopedTypes = typeof(IArmorGetter).AsEnumerable();\n\n// User can now set the FormKey member, and the viewmodel can see the results\n}\n}\n</code></pre>"},{"location":"wpf/FormKey-Picker/#formkey-multipicker","title":"FormKey Multipicker","text":"<p>This is a picker to select any number of FormKeys.</p> <p></p>"},{"location":"wpf/FormKey-Picker/#view-side_1","title":"View Side","text":"<pre><code>&lt;UserControl\n...\nxmlns:plugins=\"clr-namespace:Mutagen.Bethesda.WPF.Plugins;assembly=Mutagen.Bethesda.WPF\" &gt;\n&lt;plugins:FormKeyMultiPicker\nFormKeys=\"{Binding MyFormKeys}\"\nLinkCache=\"{Binding MyLinkCache}\"\nScopedTypes=\"{Binding MyDesiredTypes}\" /&gt;\n&lt;/UserControl&gt;\n</code></pre>"},{"location":"wpf/FormKey-Picker/#viewmodel-side_1","title":"ViewModel Side","text":"<pre><code>// Some mechanics shown here are from `ReactiveUI`, or `Noggog.WPF`\npublic class MyViewModel : ViewModel\n{\n// FormKeyItemViewModel provided by Mutagen.WPF\npublic ObservableCollection&lt;FormKeyItemViewModel&gt; MyFormKeys { get; } = new();\n\npublic ILinkCache MyLinkCache { get; }\n\npublic IEnumerable&lt;Type&gt; MyDesiredTypes { get; }\n\npublic MyViewModel()\n{\n// Create a GameEnvironment, to get a LinkCache connected to the current users' setup\nvar env = GameEnvironment.Typical.Skyrim(\nSkyrimRelease.SkyrimSE, // By passing in this preference, we only cache FormKey/EditorID info, keeping memory usage down\nLinkCachePreferences.OnlyIdentifiers());\n\n// When the ViewModel is destroyed, clean up the environment object.  Good practice\nenv.DisposeWith(this);\n\n// Set the ViewModel's LinkCache to the one given by the environment\nLinkCache = env.LinkCache;\n\n// We only care about Armor records\nScopedTypes = typeof(IArmorGetter).AsEnumerable();\n\n// User can now fill FormKeys collection, and the viewmodel can see the results\n}\n}\n</code></pre>"},{"location":"wpf/ModKey-Picker/","title":"ModKey Picker","text":"<p>The ModKey Picker helps users select mod(s) by typing in their names.</p> <p>The picker can reference certain objects to know what mods actually exist on a user's active load order: - A Load Order object - Any enumerable of type <code>ModKey</code> or <code>IModListingGetter</code> - An <code>IObservable&lt;IChangeSet&lt;T&gt;&gt;</code> of type <code>ModKey</code> or <code>IModListingGetter</code>. (Reactive Extension concepts)</p> <p>Make sure you've added the Required Resources, or the controls will not have any display.</p> <p>The Mutagen Test Display app utilizes the ModKey pickers, and provides a good example of how to use them from within a WPF app.</p>"},{"location":"wpf/ModKey-Picker/#single-picker","title":"Single Picker","text":"<p>This is a picker to select a single ModKey.</p> <p></p>"},{"location":"wpf/ModKey-Picker/#view-side","title":"View Side","text":"<pre><code>&lt;UserControl\n...\nxmlns:plugins=\"clr-namespace:Mutagen.Bethesda.WPF.Plugins;assembly=Mutagen.Bethesda.WPF\" &gt;\n&lt;plugins:ModKeyPicker ModKey=\"{Binding MyModKey}\"\nSearchableMods=\"{Binding MyAvailableMods}\" /&gt;\n&lt;/UserControl&gt;\n</code></pre>"},{"location":"wpf/ModKey-Picker/#viewmodel-side","title":"ViewModel Side","text":"<pre><code>// Some mechanics shown here are from `ReactiveUI`, or `Noggog.WPF`\npublic class MyViewModel : ViewModel\n{\n[Reactive]\npublic ModKey MyModKey { get; set; }\n\npublic object MyAvailableMods { get; }\n\npublic MyViewModel()\n{\n// Create a GameEnvironment, to get a LoadOrder connected to the current users' setup\nvar env = GameEnvironment.Typical.Skyrim(\nSkyrimRelease.SkyrimSE, // By passing in this preference, we only cache FormKey/EditorID info, keeping memory usage down\nLinkCachePreferences.OnlyIdentifiers());\n\n// When the ViewModel is destroyed, clean up the environment object.  Good practice\nenv.DisposeWith(this);\n\n// Set the ViewModel's available mods to the LoadOrder given by the environment\nMyAvailableMods = env.LoadOrder;\n\n// User can now set the ModKey member, and the viewmodel can see the results\n}\n}\n</code></pre>"},{"location":"wpf/ModKey-Picker/#modkey-multipicker","title":"ModKey Multipicker","text":"<p>This is a picker to select any number of ModKeys.</p> <p></p>"},{"location":"wpf/ModKey-Picker/#view-side_1","title":"View Side","text":"<pre><code>&lt;UserControl\n...\nxmlns:plugins=\"clr-namespace:Mutagen.Bethesda.WPF.Plugins;assembly=Mutagen.Bethesda.WPF\" &gt;\n&lt;plugins:ModKeyMultiPicker\nModKeys=\"{Binding MyModKeys}\"\nSearchableMods=\"{Binding MyAvailableMods}\" /&gt;\n&lt;/UserControl&gt;\n</code></pre>"},{"location":"wpf/ModKey-Picker/#viewmodel-side_1","title":"ViewModel Side","text":"<pre><code>// Some mechanics shown here are from `ReactiveUI`, or `Noggog.WPF`\npublic class MyViewModel : ViewModel\n{\n// ModKeyItemViewModel provided by Mutagen.WPF\npublic ObservableCollection&lt;ModKeyItemViewModel&gt; MyModKeys { get; } = new();\n\npublic object MyAvailableMods { get; }\n\npublic MyViewModel()\n{\n// Create a GameEnvironment, to get a LoadOrder connected to the current users' setup\nvar env = GameEnvironment.Typical.Skyrim(\nSkyrimRelease.SkyrimSE, // By passing in this preference, we only cache FormKey/EditorID info, keeping memory usage down\nLinkCachePreferences.OnlyIdentifiers());\n\n// When the ViewModel is destroyed, clean up the environment object.  Good practice\nenv.DisposeWith(this);\n\n// Set the ViewModel's available mods to the LoadOrder given by the environment\nMyAvailableMods = env.LinkCache;\n\n// User can now set the MyModKeys member, and the viewmodel can see the results\n}\n}\n</code></pre>"},{"location":"wpf/Reflection-Powered-Settings/","title":"Reflection Powered Settings","text":"<p>This is a control that is able to attach to any DTO (Data Transfer Object) style class and generate a UI for each of the fields.  This is very good for getting a basic settings editor up and running with minimal WPF experience.</p> <p>Originally it was part of Synthesis to provide UI controls for patcher settings, but has been moved up to Mutagen's libraries for more general use.</p>"},{"location":"wpf/Reflection-Powered-Settings/#overview","title":"Overview","text":"<p>Let's take an example DTO class <pre><code>public class TestSettings\n{\npublic bool MyBool;\npublic string MyString = string.Empty;\npublic FormKey MyFormKey;\npublic IFormLinkGetter&lt;IArmorGetter&gt; MyArmor = FormLink&lt;IArmorGetter&gt;.Null;\n}\n</code></pre></p> <p>We can supply that definition to this control, and get a UI immediately:</p> <p></p> <p>As such, it is an easy way to get a decent UI for any class, and is very helpful if: - You aren't used to WPF and just want to get something up and running - If you don't know ahead of time what fields will exist (Synthesis patchers being a prime example)</p>"},{"location":"wpf/Reflection-Powered-Settings/#nesting","title":"Nesting","text":"<p>The reflection systems allow nested classes, and utilize them to create \"sections\".</p> <p>Take this modified setup for example: <pre><code>public class TestSettings\n{\npublic bool MyBool;\npublic string MyString = string.Empty;\npublic FormKey MyFormKey;\npublic IFormLinkGetter&lt;IArmorGetter&gt; MyArmor = FormLink&lt;IArmorGetter&gt;.Null;\npublic SubSettings SubSetting = new();\n}\n\npublic class TopLevelSettings\n{\npublic TestSettings SectionOne = new();\npublic TestSettings SectionTwo = new();\n}\n\npublic class SubSettings\n{\npublic bool SubSetting;\n}\n</code></pre></p> <p>This would yield the following display:</p> <p></p>"},{"location":"wpf/Reflection-Powered-Settings/#attributes","title":"Attributes","text":"<p>Since the internal systems are constructing a view for you based on the contents of your class, you have reduced control over what is displayed, where, and how.</p> <p>The system provides some Attributes to help give back some of this control.  They all live within the namespace <code>Mutagen.Bethesda.WPF.Reflection.Attributes</code></p> <p>NOTE:  The naming of these attributes differs slightly from the names Synthesis uses for its autogenerated setting systems</p>"},{"location":"wpf/Reflection-Powered-Settings/#ignore","title":"Ignore","text":"<p>A marker attribute that will make a specific field not display</p> <pre><code>[Ignore]\npublic bool MyIgnoredBool { get; set; }\n</code></pre>"},{"location":"wpf/Reflection-Powered-Settings/#tooltip","title":"Tooltip","text":"<p>Sets the tooltip to display</p> <pre><code>[Tooltip(\"I am a setting with a lot of detail to consider\")\npublic bool SomeComplexSetting { get; set; }\n</code></pre>"},{"location":"wpf/Reflection-Powered-Settings/#settingname","title":"SettingName","text":"<p>Will set explicitly what text to display as the name for the field</p> <pre><code>[SettingName(\"Please Display This Text\")\npublic bool SomeDerpyName { get; set; }\n</code></pre>"},{"location":"wpf/Reflection-Powered-Settings/#jsondiskname","title":"JsonDiskName","text":"<p>An attribute to change what text key is used when persisting/loading from json</p> <pre><code>[JsonDiskName(\"some-setting\")\npublic bool SomeSetting { get; set; }\n</code></pre>"},{"location":"wpf/Reflection-Powered-Settings/#maintainorder","title":"MaintainOrder","text":"<p>Unfortunately, C# cannot properly guarantee order of fields when utilizing reflection.  This attribute is a marker that helps maintain desired ordering.</p> <pre><code>[MaintainOrder]\npublic bool FirstSetting { get; set; }\n\n[MaintainOrder]\npublic bool SecondSetting { get; set; }\n</code></pre>"},{"location":"wpf/Reflection-Powered-Settings/#objectnamemember","title":"ObjectNameMember","text":"<p>This attribute applies to the settings class itself, and defines the object type naming to show when nested classes are involved.</p> <pre><code>[ObjectNameMember(nameof(TestSettings.MyString))]\npublic class TestSettings\n{\n// Will now drive the text displayed when in a nested scenario\npublic string MyString = string.Empty;\n}\n</code></pre> <p>Now <code>MyString</code> drives the display in the top navigation bar</p> <p></p>"},{"location":"wpf/Reflection-Powered-Settings/#formlinkpickercustomization","title":"FormLinkPickerCustomization","text":"<p>Allows you to list explicitly the types that should be allowed in the picker.  It loses generic type safety, so only preferable if there is not already a LinkInterface or AspectInterface that describes the several types you want to target.</p> <pre><code>[FormLinkPickerCustomization(typeof(IArmorGetter), typeof(IWeaponGetter))]\npublic IFormLinkGetter ArmorsAndWeapons { get; set; } = FormLinkInformation.Null;\n</code></pre>"},{"location":"wpf/Reflection-Powered-Settings/#allowed-field-types","title":"Allowed Field Types","text":"<ul> <li><code>bool</code></li> <li><code>string</code></li> <li>Integers (signed and unsigned)</li> <li><code>float</code></li> <li><code>double</code></li> <li><code>decimal</code></li> <li><code>ModKey</code></li> <li><code>FormKey</code></li> <li>FormLinks</li> <li>Other classes with appropriate fields</li> <li>Lists/Arrays/HashSets/IEnumerables (of the above types)</li> <li>Dictionaries, in certain scenarios:</li> <li>Key is an enum</li> <li>Key is a <code>string</code></li> </ul>"},{"location":"wpf/Reflection-Powered-Settings/#implementing-within-a-ui-yourself","title":"Implementing Within a UI Yourself","text":"<p>Note that Synthesis users do not need to worry about any of this, as it is handled for them.  But if you're making a UI of your own, and want to lean on the autogenerated setting systems, this would be how to do it.</p>"},{"location":"wpf/Reflection-Powered-Settings/#view-side","title":"View Side","text":"<pre><code>&lt;UserControl\n...\nxmlns:refl=\"clr-namespace:Mutagen.Bethesda.WPF.Reflection;assembly=Mutagen.Bethesda.WPF\" &gt;\n&lt;refl:AutogeneratedSettingView DataContext=\"{Binding MyReflectionViewModel}\" /&gt;\n&lt;/UserControl&gt;\n</code></pre>"},{"location":"wpf/Reflection-Powered-Settings/#viewmodel-side","title":"ViewModel Side","text":"<pre><code>// Some mechanics shown here are from `ReactiveUI`, or `Noggog.WPF`\npublic class MyViewModel : ViewModel\n{\npublic ReflectionSettingsVM MyReflectionViewModel { get; }\n\npublic MyViewModel()\n{\n// Create a GameEnvironment\nvar env = GameEnvironment.Typical.Skyrim(\nSkyrimRelease.SkyrimSE, // By passing in this preference, we only cache FormKey/EditorID info, keeping memory usage down\nLinkCachePreferences.OnlyIdentifiers());\n\n// When the ViewModel is destroyed, clean up the environment object.  Good practice\nenv.DisposeWith(this);\n\n// Create a prototype instance of the class we want it to display\nvar defaultSettings = new TestSettings()\n{\n// Can specify some default settings we want to appear\nMyBool = true\n};\n\nMyReflectionViewModel = new ReflectionSettingsVM(\nReflectionSettingsParameters.CreateFrom(\n// Give it the class we want to display\ndefaultSettings,\n// Can give it a live load order, or just some raw listings\nenv.LoadOrder.Select(x =&gt; new ModListingVM(x.Value, env.DataFolderPath.Path)),\n// Give it the link cache, for lookups if needed\nenv.LinkCache));\n\n// Reflection display systems will now take over and display the appropriate fields\n}\n\n// Function save the current state of the reflection display to a json file\npublic void SaveToDisk(string somePath)\n{\nvar jsonObj = new JObject();\nMyReflectionViewModel.ObjVM.Persist(jsonObj);\nFile.WriteAllText(somePath, jsonObj.ToString());\n}\n\n// More functionality to access data from the reflection view will be added\n}\n</code></pre>"}]}